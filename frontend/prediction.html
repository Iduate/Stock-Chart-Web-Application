<!DOCTYPE html>
<html lang="ko">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ì˜ˆì¸¡í•˜ê¸° - StockChart</title>
    <link rel="icon"
        href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='.9em' font-size='90'>ğŸ“ˆ</text></svg>">

    <!-- Tailwind CSS - Production Version -->
    <link href="https://cdn.jsdelivr.net/npm/tailwindcss@2.2.19/dist/tailwind.min.css" rel="stylesheet">
    <style>
        /* Custom Korean Chart Styles */
        .korean-chart {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        }
        
        /* TradingView-like colors */
        .text-tv-darker { color: #0d1421; }
        .bg-tv-darker { background-color: #0d1421; }
        .text-tv-dark { color: #131722; }
        .bg-tv-dark { background-color: #131722; }
        .text-tv-card { color: #1e222d; }
        .bg-tv-card { background-color: #1e222d; }
        .text-tv-light { color: #2a2e39; }
        .bg-tv-light { background-color: #2a2e39; }
        .text-tv-border { color: #363a45; }
        .bg-tv-border { background-color: #363a45; }
        .text-tv-blue { color: #2962ff; }
        .bg-tv-blue { background-color: #2962ff; }
        .text-tv-green { color: #26a69a; }
        .bg-tv-green { background-color: #26a69a; }
        .text-tv-red { color: #ef5350; }
        .bg-tv-red { background-color: #ef5350; }
        .text-tv-text { color: #d1d4dc; }
        .bg-tv-text { background-color: #d1d4dc; }
        .text-tv-text-secondary { color: #868993; }
        .bg-tv-text-secondary { background-color: #868993; }
        .border-tv-border { border-color: #363a45; }
        
        
        /* TradingView-style chart specific styling */
        .tradingview-chart {
            background: #ffffff;
            border: 1px solid #e0e0e0;
        }
        
        .tradingview-header {
            background: #2a2d3a;
            border-bottom: 1px solid #3a3d4a;
        }
        
        .tradingview-price-bar {
            background: #f8f9fa;
            border-bottom: 1px solid #dee2e6;
        }
        
        .tradingview-controls {
            background: #f1f3f4;
            border-top: 1px solid #dadce0;
        }
        
        /* BOSS REQUIREMENT: VERY VISIBLE TIME INTERVAL BUTTONS */
        .time-interval-btn.active {
            background-color: #1976D2 !important;
            color: white !important;
            font-weight: 600 !important;
        }
        
        .time-interval-btn:hover {
            background-color: #e3f2fd !important;
            color: #1976D2 !important;
        }
        
        /* BOSS REQUIREMENT: PROMINENT TIME INTERVAL BUTTONS */
        .time-interval-btn {
            transition: all 0.2s ease;
            font-weight: 500;
            min-width: 40px !important;
            height: 32px !important;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            border: 1px solid #d0d0d0 !important;
            background-color: #f8f9fa !important;
            color: #333 !important;
            font-size: 12px !important;
        }
        
        .time-interval-btn.active {
            background-color: #1976D2 !important;
            color: white !important;
            font-weight: 600;
        }
        
        /* BOSS REQUIREMENT: EXACTLY 5 SIMPLE BUTTONS */
        .simple-time-btn {
            padding: 8px 16px !important;
            margin: 0 3px !important;
            background: white !important;
            border: 1px solid #d1d5db !important;
            border-radius: 6px !important;
            font-size: 14px !important;
            font-weight: 500 !important;
            color: #374151 !important;
            cursor: pointer !important;
            transition: all 0.2s ease !important;
            min-width: 60px !important;
            text-align: center !important;
            box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05) !important;
        }
        
        .simple-time-btn:hover {
            background: #f3f4f6 !important;
            border-color: #9ca3af !important;
            transform: translateY(-1px) !important;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1) !important;
        }
        
        .simple-time-btn.active {
            background: #2563eb !important;
            color: white !important;
            border-color: #2563eb !important;
            font-weight: 600 !important;
            box-shadow: 0 2px 4px rgba(37, 99, 235, 0.3) !important;
        }
        
        /* TradingView-style Mouse Wheel Interactions */
        .chart-container {
            cursor: crosshair;
            user-select: none;
            position: relative;
            overflow: hidden;
        }
        
        .chart-container:hover {
            cursor: crosshair;
        }
        
        .chart-container.zooming {
            cursor: zoom-in;
        }
        
        .chart-container.scrolling {
            cursor: grab;
        }
        
        .chart-container.scrolling:active {
            cursor: grabbing;
        }
        
        /* TradingView-style zoom indicator */
        .tv-zoom-indicator {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
        }
        
        /* TradingView-style wheel control buttons */
        .wheel-controls .btn {
            min-width: 32px !important;
            height: 32px !important;
            padding: 4px !important;
            margin: 0 2px !important;
            background: #f8f9fa !important;
            border: 1px solid #dee2e6 !important;
            border-radius: 4px !important;
            font-size: 14px !important;
            transition: all 0.2s ease !important;
        }
        
        .wheel-controls .btn:hover {
            background: #e9ecef !important;
            transform: scale(1.05) !important;
        }
        
        .wheel-controls .btn:active {
            transform: scale(0.95) !important;
        }
        
        /* Prevent text selection during wheel interactions */
        .chart-container * {
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            user-select: none;
        }
        
        .chart-type-btn {
            transition: all 0.2s ease;
            min-width: 24px;
            height: 24px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
        }
        
        .chart-type-btn.active {
            background-color: #e3f2fd;
            color: #1976D2;
        }
        
        /* Prediction tooltip styling */
        #predictionTooltip.hidden {
            display: none !important;
        }
        
        /* Responsive adjustments */
        @media (max-width: 768px) {
            .chart-area {
                height: 450px !important;
            }
            
            #volumeContainer {
                height: 120px !important;
            }
        }
    </style>

    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link
        href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Noto+Sans+KR:wght@300;400;500;600;700&display=swap"
        rel="stylesheet">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css">

    <!-- Enhanced Chart Manager -->
    <script src="js/enhanced-chart-manager.js"></script>
    
    <!-- TradingView-style Mouse Wheel Controller -->
    <script src="js/tradingview-wheel-controller.js"></script>
    
    <!-- TradingView-style lightweight chart engine -->
    <script src="js/tradingview-chart-engine.js"></script>
    
    <script>
        // Pure Candlestick Controller - NOT inheriting from LineController to avoid line interference
        class CandlestickController extends Chart.DatasetController {
            static id = 'candlestick';
            static defaults = {
                dataElementType: 'point',
                dataElementOptions: {
                    pointRadius: 0,
                    pointHoverRadius: 5,
                    hitRadius: 5,
                    hoverRadius: 5,
                    backgroundColor: 'transparent',
                    borderColor: 'transparent'
                },
                datasetElementType: false,
                hover: {
                    animationDuration: 0
                },
                animation: {
                    duration: 0
                }
            };

            initialize() {
                this.enableOptionSharing = true;
                super.initialize();
            }

            // Use point elements for tooltips only
            dataElementType = Chart.PointElement || Chart.elements.Point;

            addElements() {
                const meta = this.getMeta();
                const data = this.getDataset().data || [];
                
                meta.data = meta.data || [];
                for (let i = meta.data.length; i < data.length; i++) {
                    meta.data[i] = new (this.dataElementType)();
                }
            }

            addElementAndReset(index) {
                const element = new (this.dataElementType)();
                this.getMeta().data.splice(index, 0, element);
                this.updateElement(element, index, 'reset');
            }

            updateElements(elements, start, count, mode) {
                const dataset = this.getDataset();
                const xScale = this.chart.scales.x;
                const yScale = this.chart.scales.y;
                
                for (let i = start; i < start + count; i++) {
                    const element = elements[i];
                    const dataPoint = dataset.data[i] || {};
                    
                    if (dataPoint && typeof dataPoint.o !== 'undefined') {
                        const properties = {
                            x: xScale.getPixelForValue(dataPoint.x),
                            y: yScale.getPixelForValue(dataPoint.c), // Use close price for positioning
                            skip: false,
                            // Add proper options to prevent hitRadius errors
                            options: {
                                pointRadius: 0,
                                pointHoverRadius: 5,
                                hitRadius: 5,
                                hoverRadius: 5,
                                backgroundColor: 'transparent',
                                borderColor: 'transparent'
                            }
                        };
                        
                        // Store OHLC data for tooltips
                        element.parsed = {
                            x: dataPoint.x,
                            y: dataPoint.c,
                            o: dataPoint.o,
                            h: dataPoint.h,
                            l: dataPoint.l,
                            c: dataPoint.c
                        };
                        
                        this.updateElement(element, i, properties, mode);
                    } else {
                        element.skip = true;
                    }
                }
            }

            getPixelForValue(value, index) {
                const xScale = this.chart.scales.x;
                const yScale = this.chart.scales.y;
                
                if (typeof value === 'number' && yScale) {
                    return yScale.getPixelForValue(value);
                } else if (xScale) {
                    return xScale.getPixelForValue(value);
                }
                return 0;
            }

            // Critical: Override parse method to handle OHLC data properly
            parse(start, count) {
                const meta = this.getMeta();
                const dataset = this.getDataset();
                const data = dataset.data || [];
                
                const parsed = [];
                for (let i = start; i < start + count; i++) {
                    const dataPoint = data[i];
                    if (dataPoint && typeof dataPoint.o !== 'undefined') {
                        parsed[i] = {
                            x: dataPoint.x,
                            y: dataPoint.c, // Use close price as main Y value
                            o: dataPoint.o,
                            h: dataPoint.h,
                            l: dataPoint.l,
                            c: dataPoint.c
                        };
                    } else {
                        parsed[i] = null;
                    }
                }
                return parsed;
            }

            // Override parseObjectData to handle OHLC structure
            parseObjectData(meta, data, start, count) {
                const parsed = [];
                for (let i = start; i < start + count; i++) {
                    const dataPoint = data[i];
                    if (dataPoint && typeof dataPoint.o !== 'undefined') {
                        parsed[i] = {
                            x: dataPoint.x,
                            y: dataPoint.c,
                            o: dataPoint.o,
                            h: dataPoint.h,
                            l: dataPoint.l,
                            c: dataPoint.c
                        };
                    } else {
                        parsed[i] = null;
                    }
                }
                return parsed;
            }

            // Override ALL Chart.js default drawing to prevent interference
            linkScales() {
                // Disable scale linking
            }

            buildOrUpdateElements() {
                // Call parent to create elements for tooltips
                super.buildOrUpdateElements();
            }

            update(mode) {
                // Override update to prevent default chart drawing
                const meta = this.getMeta();
                const dataset = this.getDataset();
                
                if (dataset.data && dataset.data.length > 0) {
                    // Only update our elements, don't call super.update()
                    this.updateElements(meta.data || [], 0, dataset.data.length, mode);
                }
            }

            // FORCE: Override the base chart's draw method to only draw our candlesticks
            beforeDraw() {
                // Clear any existing Chart.js elements
                const ctx = this.chart.ctx;
                const chartArea = this.chart.chartArea;
                
                // Clear only the chart area, not axes
                ctx.save();
                ctx.clearRect(chartArea.left, chartArea.top, 
                            chartArea.right - chartArea.left, 
                            chartArea.bottom - chartArea.top);
                ctx.restore();
            }

            // Custom hover without line behavior
            setHoverStyle(element, datasetIndex, index) {}
            removeHoverStyle(element, datasetIndex, index) {}

            // Main draw function - FORCE THICK KOREAN CANDLESTICKS TO APPEAR
            draw() {
                const ctx = this.chart.ctx;
                const meta = this.getMeta();
                const dataset = this.getDataset();
                
                if (!meta.data || !dataset.data || dataset.data.length === 0) return;

                console.log(`ï¿½ FORCING ${dataset.data.length} THICK Korean candlesticks to display`);
                
                // FORCE CLEAR CANVAS AND REDRAW
                ctx.save();
                
                // Get chart dimensions
                const chartArea = this.chart.chartArea;
                const xScale = this.chart.scales.x;
                const yScale = this.chart.scales.y;
                
                // BOSS REQUIREMENT: FIXED SPACING - NO GAPS WHEN SCROLLING
                const dataCount = 25; // FIXED - always 25 candlesticks for consistent spacing
                const availableWidth = chartArea.right - chartArea.left;
                const spacing = availableWidth / dataCount; // Fixed calculation
                
                // NO GAP AT ALL - CANDLESTICKS TOUCHING
                const candleWidth = Math.floor(spacing); // 100% width - TOUCHING each other
                const wickWidth = Math.max(2, Math.floor(candleWidth / 10)); // Thin wicks like reference
                
                console.log(`EXACT SPACING MATCH - Candle: ${candleWidth}px, Wick: ${wickWidth}px, Count: ${dataCount}`);
                
                console.log(`ï¿½ TradingView Style - Candle: ${candleWidth}px, Wick: ${wickWidth}px, Spacing: ${spacing}px, Count: ${dataCount}`);

                // DRAW EACH CANDLESTICK WITH PROPER TRADINGVIEW PROPORTIONS
                dataset.data.slice(0, dataCount).forEach((dataPoint, index) => {
                    if (!dataPoint || typeof dataPoint.o === 'undefined') return;
                    
                    // FIX X POSITION - calculate manually if scale fails
                    let x;
                    try {
                        x = xScale.getPixelForValue(dataPoint.x);
                        // If x is invalid (negative or extreme), calculate manually
                        if (x < 0 || x > 10000 || isNaN(x)) {
                            throw new Error('Invalid x coordinate');
                        }
                    } catch (e) {
                        // Manual calculation: Extra thick candles with minimal gaps
                        const startX = chartArea.left + 10; // Minimal margins for maximum width
                        const endX = chartArea.right - 10; // Minimal margins for maximum width  
                        const availableX = endX - startX;
                        x = startX + (index * spacing) + (spacing / 2); // Center each very thick candle
                    }
                    
                    // Get Y positions with fallback calculation
                    let high, low, open, close;
                    try {
                        high = yScale.getPixelForValue(dataPoint.h);
                        low = yScale.getPixelForValue(dataPoint.l);
                        open = yScale.getPixelForValue(dataPoint.o);
                        close = yScale.getPixelForValue(dataPoint.c);
                        
                        // If Y values are invalid, calculate manually
                        if (high < 0 || high > 10000 || isNaN(high) || 
                            low < 0 || low > 10000 || isNaN(low)) {
                            throw new Error('Invalid y coordinates');
                        }
                    } catch (e) {
                        // Manual Y calculation: map price range to chart height
                        const priceValues = dataset.data.map(d => [d.h, d.l, d.o, d.c]).flat();
                        const minPrice = Math.min(...priceValues);
                        const maxPrice = Math.max(...priceValues);
                        const priceRange = maxPrice - minPrice;
                        
                        const chartHeight = chartArea.bottom - chartArea.top;
                        const margin = chartHeight * 0.1; // 10% margin top/bottom
                        const availableHeight = chartHeight - (margin * 2);
                        
                        // Map prices to pixel positions (inverted Y-axis)
                        high = chartArea.top + margin + ((maxPrice - dataPoint.h) / priceRange) * availableHeight;
                        low = chartArea.top + margin + ((maxPrice - dataPoint.l) / priceRange) * availableHeight;
                        open = chartArea.top + margin + ((maxPrice - dataPoint.o) / priceRange) * availableHeight;
                        close = chartArea.top + margin + ((maxPrice - dataPoint.c) / priceRange) * availableHeight;
                    }
                    
                    // BOSS REQUIREMENT: Traditional Korean chart colors like reference image
                    const isUp = dataPoint.c >= dataPoint.o;
                    const bodyColor = isUp ? '#FF0000' : '#0066FF'; // Traditional red/blue for maximum visibility
                    const wickColor = isUp ? '#CC0000' : '#0044CC'; // Darker variants
                    const borderColor = isUp ? '#990000' : '#002299'; // Darkest borders
                    
                    console.log(`ğŸ•¯ï¸ Drawing candle ${index + 1} at FIXED x=${x}, width=${candleWidth}px, colors=${bodyColor}`);
                    
                    // FORCE DRAW SUPER THICK WICK
                    ctx.strokeStyle = wickColor;
                    ctx.lineWidth = wickWidth;
                    ctx.lineCap = 'butt';
                    // Draw normal thickness wick like reference
                    ctx.lineWidth = wickWidth; // Normal wick thickness
                    
                    // Draw the main wick - simple line like reference
                    ctx.beginPath();
                    ctx.moveTo(x, high);
                    ctx.lineTo(x, low);
                    ctx.stroke();
                    
                    // REFERENCE IMAGE STYLE CANDLE BODY
                    const bodyTop = Math.min(open, close);
                    const bodyBottom = Math.max(open, close);
                    
                    // Good proportions like reference - not too thick, not too thin
                    const minHeight = 3; // Small minimum height
                    const bodyHeight = Math.max(bodyBottom - bodyTop, minHeight);
                    const adjustedBodyTop = bodyBottom === bodyTop ? bodyTop - minHeight/2 : bodyTop;
                    
                    // Fill body like reference
                    ctx.fillStyle = bodyColor;
                    ctx.fillRect(x - candleWidth / 2, adjustedBodyTop, candleWidth, bodyHeight);
                    
                    // Clean border like reference
                    ctx.strokeStyle = borderColor;
                    ctx.lineWidth = 1; // Clean 1px border
                    ctx.strokeRect(x - candleWidth / 2, adjustedBodyTop, candleWidth, bodyHeight);
                    
                    console.log(`âœ… Forced candle ${index + 1} drawn: rect(${x - candleWidth / 2}, ${bodyTop}, ${candleWidth}, ${bodyHeight})`);
                });
                
                ctx.restore();
                console.log('PERFECT REFERENCE MATCH - EXACT PROPORTIONS ACHIEVED');
            }
        }

        // Register custom candlestick controller
        Chart.register(CandlestickController);

        // Register all Chart.js components
        if (typeof Chart !== 'undefined') {
            try {
                // Chart.js 4.x compatible registration
                if (Chart.registry && Chart.LinearScale) {
                    Chart.register(
                        Chart.LineController,
                        Chart.BarController,
                        Chart.CategoryScale,
                        Chart.LinearScale,
                        Chart.TimeScale,
                        Chart.Tooltip,
                        Chart.Legend,
                        Chart.LineElement,
                        Chart.PointElement,
                        Chart.BarElement,
                        Chart.Filler,
                        CandlestickController
                    );
                } else if (Chart.registerables && Array.isArray(Chart.registerables)) {
                    Chart.register(...Chart.registerables, CandlestickController);
                }
                console.log('âœ… Chart.js core components and custom candlestick registered');
            } catch (e) {
                console.log('Chart.js registration error:', e);
            }
        }
    </script>

    <style>
        /* Custom styles for Korean candlestick chart */
        .korean-chart {
            background: #f5f5f5;
            border: 1px solid #ddd;
        }
        
        .chart-header {
            background: #2c3e50;
            color: white;
            padding: 8px;
            font-size: 12px;
        }
        
        .stock-info-bar {
            background: #34495e;
            color: white;
            padding: 4px 8px;
            font-size: 11px;
            border-bottom: 1px solid #555;
        }
        
        .chart-container {
            background: white;
            position: relative;
            border-radius: 8px;
            overflow: hidden;
        }
        
        .price-scale {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 60px;
            background: #ecf0f1;
            border-left: 1px solid #bdc3c7;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 10px 5px;
            font-size: 10px;
            color: #2980b9;
        }
        
        .volume-scale {
            position: absolute;
            right: 0;
            top: 0;
            bottom: 0;
            width: 60px;
            background: #ecf0f1;
            border-left: 1px solid #bdc3c7;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 5px;
            font-size: 10px;
            color: #2980b9;
        }
        
        .date-nav-bar {
            background: #34495e;
            color: white;
            padding: 8px;
            font-size: 11px;
        }
        
        .date-indicators {
            display: flex;
            gap: 1px;
            align-items: center;
            margin: 5px 0;
        }
        
        .date-indicator {
            width: 3px;
            height: 12px;
        }
        
        .date-indicator.up { background: #3498db; }
        .date-indicator.down { background: #e74c3c; }
        .date-indicator.selected { background: #f1c40f; }
    </style>
</head>

<body class="bg-tv-darker text-tv-text min-h-screen">
    <!-- Navigation Bar -->
    <nav class="bg-tv-dark border-b border-tv-border sticky top-0 z-40 backdrop-blur-md">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <div class="flex items-center justify-between h-16">
                <!-- Logo -->
                <div class="flex items-center space-x-3">
                    <a href="home.html"
                        class="flex items-center space-x-2 text-tv-text hover:text-tv-blue transition-colors">
                        <div class="w-8 h-8 bg-tv-blue rounded-lg flex items-center justify-center">
                            <i class="fas fa-chart-line text-white text-sm"></i>
                        </div>
                        <span class="text-xl font-bold">StockChart</span>
                    </a>
                </div>

                <!-- Desktop Navigation -->
                <div class="hidden lg:flex items-center space-x-1">
                    <a href="home.html"
                        class="px-4 py-2 rounded-lg text-tv-text-secondary hover:text-tv-text hover:bg-tv-light transition-all duration-200">í™ˆ</a>
                    <a href="charts.html"
                        class="px-4 py-2 rounded-lg text-tv-text-secondary hover:text-tv-text hover:bg-tv-light transition-all duration-200">ì°¨íŠ¸
                        ë³´ë“œ</a>
                    <a href="prediction.html"
                        class="px-4 py-2 rounded-lg text-tv-text bg-tv-blue bg-opacity-20 border border-tv-blue">ì˜ˆì¸¡í•˜ê¸°</a>
                    <a href="my-predictions.html"
                        class="px-4 py-2 rounded-lg text-tv-text-secondary hover:text-tv-text hover:bg-tv-light transition-all duration-200">ë‚´
                        ì˜ˆì¸¡</a>
                    <a href="ranking.html"
                        class="px-4 py-2 rounded-lg text-tv-text-secondary hover:text-tv-text hover:bg-tv-light transition-all duration-200">ë­í‚¹</a>
                    <a href="events.html"
                        class="px-4 py-2 rounded-lg text-tv-text-secondary hover:text-tv-text hover:bg-tv-light transition-all duration-200">ì´ë²¤íŠ¸</a>
                    <a href="subscription.html"
                        class="px-4 py-2 rounded-lg text-tv-text-secondary hover:text-tv-text hover:bg-tv-light transition-all duration-200">êµ¬ë…</a>
                    <button onclick="showLoginModal()"
                        class="ml-4 bg-tv-blue hover:bg-blue-600 text-white px-6 py-2 rounded-lg font-semibold transition-colors">ë¡œê·¸ì¸</button>
                </div>

                <!-- Mobile menu button -->
                <div class="lg:hidden">
                    <button onclick="toggleMobileMenu()"
                        class="relative z-[99999] text-tv-text-secondary hover:text-white p-2 rounded-lg transition-all duration-300 hover:bg-tv-light"
                        id="mobileMenuButton" aria-label="ë©”ë‰´ ì—´ê¸°">
                        <div class="w-6 h-6 flex flex-col justify-center items-center">
                            <span
                                class="hamburger-line w-6 h-0.5 bg-current transition-all duration-300 transform origin-center"></span>
                            <span
                                class="hamburger-line w-6 h-0.5 bg-current transition-all duration-300 transform origin-center mt-1.5"></span>
                            <span
                                class="hamburger-line w-6 h-0.5 bg-current transition-all duration-300 transform origin-center mt-1.5"></span>
                        </div>
                    </button>
                </div>
            </div>
        </div>
    </nav>

    <!-- Mobile Menu -->
    <div id="mobileMenu"
        class="lg:hidden fixed inset-0 z-[9999] transform translate-x-full transition-transform duration-300 ease-in-out">
        <div class="absolute inset-0 bg-black bg-opacity-50" onclick="toggleMobileMenu()"></div>
        <div class="absolute right-0 top-0 h-full w-80 bg-tv-dark border-l border-tv-border shadow-2xl">
            <div class="p-6 space-y-6">
                <div class="flex items-center justify-between">
                    <h3 class="text-xl font-bold text-tv-text">ë©”ë‰´</h3>
                    <button onclick="toggleMobileMenu()" class="text-tv-text-secondary hover:text-white p-2">
                        <i class="fas fa-times text-xl"></i>
                    </button>
                </div>
                <div class="space-y-3">
                    <a href="home.html"
                        class="flex items-center space-x-3 text-tv-text-secondary hover:text-tv-text p-3 rounded-lg hover:bg-tv-light transition-all duration-200">
                        <i class="fas fa-home w-5"></i>
                        <span>í™ˆ</span>
                    </a>
                    <a href="charts.html"
                        class="flex items-center space-x-3 text-tv-text-secondary hover:text-tv-text p-3 rounded-lg hover:bg-tv-light transition-all duration-200">
                        <i class="fas fa-chart-line w-5"></i>
                        <span>ì°¨íŠ¸ ë³´ë“œ</span>
                    </a>
                    <a href="prediction.html"
                        class="flex items-center space-x-3 text-tv-text bg-tv-blue bg-opacity-20 border border-tv-blue p-3 rounded-lg">
                        <i class="fas fa-lightbulb w-5"></i>
                        <span>ì˜ˆì¸¡í•˜ê¸°</span>
                    </a>
                    <a href="my-predictions.html"
                        class="flex items-center space-x-3 text-tv-text-secondary hover:text-tv-text p-3 rounded-lg hover:bg-tv-light transition-all duration-200">
                        <i class="fas fa-user-chart w-5"></i>
                        <span>ë‚´ ì˜ˆì¸¡</span>
                    </a>
                    <a href="ranking.html"
                        class="flex items-center space-x-3 text-tv-text-secondary hover:text-tv-text p-3 rounded-lg hover:bg-tv-light transition-all duration-200">
                        <i class="fas fa-trophy w-5"></i>
                        <span>ë­í‚¹</span>
                    </a>
                    <a href="events.html"
                        class="flex items-center space-x-3 text-tv-text-secondary hover:text-tv-text p-3 rounded-lg hover:bg-tv-light transition-all duration-200">
                        <i class="fas fa-calendar w-5"></i>
                        <span>ì´ë²¤íŠ¸</span>
                    </a>
                    <a href="subscription.html"
                        class="flex items-center space-x-3 text-tv-text-secondary hover:text-tv-text p-3 rounded-lg hover:bg-tv-light transition-all duration-200">
                        <i class="fas fa-crown w-5"></i>
                        <span>êµ¬ë…</span>
                    </a>
                </div>
                <div class="pt-6 border-t border-tv-border">
                    <button onclick="showLoginModal()"
                        class="w-full bg-tv-blue hover:bg-blue-600 text-white px-6 py-3 rounded-lg font-semibold transition-colors">
                        <i class="fas fa-sign-in-alt mr-2"></i>
                        ë¡œê·¸ì¸
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Main Content -->
    <main class="py-8 bg-tv-darker min-h-screen">
        <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8">
            <!-- Page Header -->
            <div class="mb-8 text-center">
                <h1 class="text-4xl font-bold text-tv-text mb-4">ì£¼ì‹ ì˜ˆì¸¡í•˜ê¸°</h1>
                <p class="text-lg text-tv-text-secondary">ì‹¬ë³¼ ì…ë ¥ â†’ ì°¨íŠ¸ í´ë¦­ â†’ ì™„ë£Œ</p>
            </div>

            <!-- Main Form -->
            <div class="bg-tv-card border border-tv-border rounded-2xl p-8 shadow-xl">
                <form id="predictionForm" class="space-y-8">

                    <!-- Step 1: Stock Selection -->
                    <div class="space-y-4">
                        <label class="block text-lg font-semibold text-tv-text">
                            <i class="fas fa-chart-line text-tv-blue mr-2"></i>ì¢…ëª© ì„ íƒ
                        </label>

                        <!-- Stock Search -->
                        <input type="text" id="stockSearch"
                            class="w-full px-4 py-3 bg-tv-light border border-tv-border rounded-lg text-tv-text focus:ring-2 focus:ring-tv-blue focus:border-tv-blue transition-all"
                            placeholder="ì¢…ëª©ëª… ë˜ëŠ” ì‹¬ë³¼ ê²€ìƒ‰ (ì˜ˆ: AAPL, TSLA, BTC)">

                        <!-- Stock Selection Dropdown -->
                        <select id="stockSelect" name="stock_symbol" required
                            class="w-full px-4 py-3 bg-tv-light border border-tv-border rounded-lg text-tv-text focus:ring-2 focus:ring-tv-blue focus:border-tv-blue transition-all">
                            <option value="">ì¢…ëª©ì„ ì„ íƒí•˜ì„¸ìš”</option>

                            <!-- US Stocks -->
                            <optgroup label="ğŸ‡ºğŸ‡¸ ë¯¸êµ­ ì£¼ì‹">
                                <option value="AAPL">AAPL - ì• í”Œ</option>
                                <option value="MSFT">MSFT - ë§ˆì´í¬ë¡œì†Œí”„íŠ¸</option>
                                <option value="GOOGL">GOOGL - êµ¬ê¸€ (ì•ŒíŒŒë²³)</option>
                                <option value="AMZN">AMZN - ì•„ë§ˆì¡´</option>
                                <option value="TSLA">TSLA - í…ŒìŠ¬ë¼</option>
                                <option value="NVDA">NVDA - ì—”ë¹„ë””ì•„</option>
                                <option value="META">META - ë©”íƒ€ (í˜ì´ìŠ¤ë¶)</option>
                                <option value="NFLX">NFLX - ë„·í”Œë¦­ìŠ¤</option>
                                <option value="CRM">CRM - ì„¸ì¼ì¦ˆí¬ìŠ¤</option>
                                <option value="PYPL">PYPL - í˜ì´íŒ”</option>
                                <option value="ADBE">ADBE - ì–´ë„ë¹„</option>
                                <option value="INTC">INTC - ì¸í…”</option>
                                <option value="AMD">AMD - AMD</option>
                                <option value="CSCO">CSCO - ì‹œìŠ¤ì½”</option>
                                <option value="ORCL">ORCL - ì˜¤ë¼í´</option>
                                <option value="IBM">IBM - IBM</option>
                                <option value="UBER">UBER - ìš°ë²„</option>
                                <option value="SPOT">SPOT - ìŠ¤í¬í‹°íŒŒì´</option>
                                <option value="ZM">ZM - ì¤Œ</option>
                                <option value="SQ">SQ - ë¸”ë¡ (ìŠ¤í€˜ì–´)</option>
                                <option value="V">V - ë¹„ì</option>
                                <option value="MA">MA - ë§ˆìŠ¤í„°ì¹´ë“œ</option>
                                <option value="JPM">JPM - JPëª¨ê±´</option>
                                <option value="JNJ">JNJ - ì¡´ìŠ¨ì•¤ì¡´ìŠ¨</option>
                                <option value="WMT">WMT - ì›”ë§ˆíŠ¸</option>
                                <option value="PG">PG - í”„ë¡í„°ì•¤ê°¬ë¸”</option>
                                <option value="UNH">UNH - ìœ ë‚˜ì´í‹°ë“œí—¬ìŠ¤</option>
                                <option value="HD">HD - í™ˆë””í¬</option>
                                <option value="BAC">BAC - ë±…í¬ì˜¤ë¸Œì•„ë©”ë¦¬ì¹´</option>
                                <option value="DIS">DIS - ë””ì¦ˆë‹ˆ</option>
                                <option value="ADBE">ADBE - ì–´ë„ë¹„</option>
                                <option value="CRM">CRM - ì„¸ì¼ì¦ˆí¬ìŠ¤</option>
                                <option value="NOW">NOW - ì„œë¹„ìŠ¤ë‚˜ìš°</option>
                                <option value="BABA">BABA - ì•Œë¦¬ë°”ë°”</option>
                                <option value="PFE">PFE - í™”ì´ì</option>
                                <option value="KO">KO - ì½”ì¹´ì½œë¼</option>
                                <option value="PEP">PEP - í©ì‹œì½”</option>
                                <option value="TMO">TMO - ì¨ëª¨í”¼ì…”</option>
                                <option value="ABT">ABT - ì• ë²—</option>
                                <option value="COST">COST - ì½”ìŠ¤íŠ¸ì½”</option>
                                <option value="AVGO">AVGO - ë¸Œë¡œë“œì»´</option>
                                <option value="TXN">TXN - í…ì‚¬ìŠ¤ì¸ìŠ¤íŠ¸ë£¨ë¨¼íŠ¸</option>
                                <option value="QCOM">QCOM - í€„ì»´</option>
                                <option value="LLY">LLY - ì¼ë¼ì´ë¦´ë¦¬</option>
                                <option value="XOM">XOM - ì—‘ì†ëª¨ë¹Œ</option>
                                <option value="CVX">CVX - ì…°ë¸Œë¡ </option>
                                <option value="ABBV">ABBV - ì• ë¹„</option>
                                <option value="MRK">MRK - ë¨¸í¬</option>
                                <option value="ACN">ACN - ì•¡ì„¼ì¸„ì–´</option>
                                <option value="ORCL">ORCL - ì˜¤ë¼í´</option>
                                <option value="VZ">VZ - ë²„ë¼ì´ì¦Œ</option>
                                <option value="T">T - AT&T</option>
                                <option value="CMCSA">CMCSA - ì»´ìºìŠ¤íŠ¸</option>
                                <option value="MDT">MDT - ë©”ë“œíŠ¸ë¡œë‹‰</option>
                                <option value="NEE">NEE - ë„¥ìŠ¤íŠ¸ì—ë¼ì—ë„ˆì§€</option>
                            </optgroup>

                            <!-- Korean Stocks -->
                            <optgroup label="ğŸ‡°ğŸ‡· í•œêµ­ ì£¼ì‹">
                                <option value="005930.KS">005930.KS - ì‚¼ì„±ì „ì</option>
                                <option value="000660.KS">000660.KS - SKí•˜ì´ë‹‰ìŠ¤</option>
                                <option value="035420.KS">035420.KS - ë„¤ì´ë²„</option>
                                <option value="207940.KS">207940.KS - ì‚¼ì„±ë°”ì´ì˜¤ë¡œì§ìŠ¤</option>
                                <option value="006400.KS">006400.KS - ì‚¼ì„±SDI</option>
                                <option value="051910.KS">051910.KS - LGí™”í•™</option>
                                <option value="096770.KS">096770.KS - SKì´ë…¸ë² ì´ì…˜</option>
                                <option value="028260.KS">028260.KS - ì‚¼ì„±ë¬¼ì‚°</option>
                                <option value="034730.KS">034730.KS - SK</option>
                                <option value="068270.KS">068270.KS - ì…€íŠ¸ë¦¬ì˜¨</option>
                                <option value="323410.KS">323410.KS - ì¹´ì¹´ì˜¤ë±…í¬</option>
                                <option value="035720.KS">035720.KS - ì¹´ì¹´ì˜¤</option>
                                <option value="352820.KS">352820.KS - í•˜ì´ë¸Œ</option>
                                <option value="003670.KS">003670.KS - í¬ìŠ¤ì½”í™€ë”©ìŠ¤</option>
                                <option value="105560.KS">105560.KS - KBê¸ˆìœµ</option>
                                <option value="055550.KS">055550.KS - ì‹ í•œì§€ì£¼</option>
                                <option value="086790.KS">086790.KS - í•˜ë‚˜ê¸ˆìœµì§€ì£¼</option>
                                <option value="017670.KS">017670.KS - SKí…”ë ˆì½¤</option>
                                <option value="030200.KS">030200.KS - KT</option>
                                <option value="032830.KS">032830.KS - ì‚¼ì„±ìƒëª…</option>
                                <option value="009150.KS">009150.KS - ì‚¼ì„±ì „ê¸°</option>
                                <option value="000270.KS">000270.KS - ê¸°ì•„</option>
                                <option value="005380.KS">005380.KS - í˜„ëŒ€ì°¨</option>
                                <option value="012330.KS">012330.KS - í˜„ëŒ€ëª¨ë¹„ìŠ¤</option>
                                <option value="066570.KS">066570.KS - LGì „ì</option>
                                <option value="003550.KS">003550.KS - LG</option>
                                <option value="018260.KS">018260.KS - ì‚¼ì„±ì—ìŠ¤ë””ì—ìŠ¤</option>
                                <option value="361610.KS">361610.KS - SKì•„ì´ì´í…Œí¬ë†€ë¡œì§€</option>
                                <option value="247540.KS">247540.KS - ì—ì½”í”„ë¡œë¹„ì— </option>
                                <option value="373220.KS">373220.KS - LGì—ë„ˆì§€ì†”ë£¨ì…˜</option>
                                <option value="036570.KS">036570.KS - ì—”ì”¨ì†Œí”„íŠ¸</option>
                                <option value="251270.KS">251270.KS - ë„·ë§ˆë¸”</option>
                                <option value="112040.KS">112040.KS - ìœ„ë©”ì´ë“œ</option>
                                <option value="259960.KS">259960.KS - í¬ë˜í”„í†¤</option>
                                <option value="035900.KS">035900.KS - JYP Ent.</option>
                                <option value="122870.KS">122870.KS - ì™€ì´ì§€ì—”í„°í…Œì¸ë¨¼íŠ¸</option>
                                <option value="041510.KS">041510.KS - ì—ìŠ¤ì— </option>
                                <option value="000810.KS">000810.KS - ì‚¼ì„±í™”ì¬</option>
                                <option value="024110.KS">024110.KS - ê¸°ì—…ì€í–‰</option>
                                <option value="316140.KS">316140.KS - ìš°ë¦¬ê¸ˆìœµì§€ì£¼</option>
                                <option value="128940.KS">128940.KS - í•œë¯¸ì•½í’ˆ</option>
                                <option value="196170.KS">196170.KS - ì•Œí…Œì˜¤ì  </option>
                                <option value="068760.KS">068760.KS - ì…€íŠ¸ë¦¬ì˜¨ì œì•½</option>
                                <option value="091990.KS">091990.KS - ì…€íŠ¸ë¦¬ì˜¨í—¬ìŠ¤ì¼€ì–´</option>
                                <option value="207940.KS">207940.KS - ì‚¼ì„±ë°”ì´ì˜¤ë¡œì§ìŠ¤</option>
                                <option value="302440.KS">302440.KS - SKë°”ì´ì˜¤ì‚¬ì´ì–¸ìŠ¤</option>
                            </optgroup>

                            <!-- Japanese Stocks -->
                            <optgroup label="ğŸ‡¯ğŸ‡µ ì¼ë³¸ ì£¼ì‹">
                                <option value="7203.T">7203.T - ë„ìš”íƒ€ìë™ì°¨</option>
                                <option value="6758.T">6758.T - ì†Œë‹ˆê·¸ë£¹</option>
                                <option value="9984.T">9984.T - ì†Œí”„íŠ¸ë±…í¬ê·¸ë£¹</option>
                                <option value="6501.T">6501.T - íˆíƒ€ì¹˜</option>
                                <option value="8306.T">8306.T - ë¯¸ì“°ë¹„ì‹œUFJì€í–‰</option>
                                <option value="4502.T">4502.T - ë‹¤ì¼€ë‹¤ì œì•½</option>
                                <option value="7974.T">7974.T - ë‹Œí…ë„</option>
                                <option value="6861.T">6861.T - í‚¤ì—”ìŠ¤</option>
                                <option value="4519.T">4519.T - ì¶”ê°€ì´ì œì•½</option>
                                <option value="8035.T">8035.T - ë„ì¿„ì¼ë ‰íŠ¸ë¡ </option>
                                <option value="9432.T">9432.T - NTT</option>
                                <option value="4661.T">4661.T - ì˜¤ë¦¬ì—”íƒˆëœë“œ</option>
                                <option value="6954.T">6954.T - íŒŒë‚™</option>
                                <option value="7751.T">7751.T - ìºë…¼</option>
                                <option value="8031.T">8031.T - ë¯¸ì“°ì´ë¬¼ì‚°</option>
                                <option value="9434.T">9434.T - ì†Œí”„íŠ¸ë±…í¬</option>
                                <option value="4568.T">4568.T - ë‹¤ì´ì´ì¹˜ì‚°ì¿„</option>
                                <option value="8058.T">8058.T - ë¯¸ì“°ë¹„ì‹œìƒì‚¬</option>
                                <option value="9433.T">9433.T - KDDI</option>
                                <option value="4063.T">4063.T - ì‹ ì—ì“°í™”í•™</option>
                                <option value="6098.T">6098.T - ë¦¬ì¿ ë£¨íŠ¸í™€ë”©ìŠ¤</option>
                                <option value="7267.T">7267.T - í˜¼ë‹¤ê¸°ì—°</option>
                                <option value="8766.T">8766.T - ë„ì¿„í•´ìƒ</option>
                                <option value="4911.T">4911.T - ì‹œì„¸ì´ë„</option>
                                <option value="2914.T">2914.T - JT</option>
                            </optgroup>

                            <!-- Indian Stocks -->
                            <optgroup label="ğŸ‡®ğŸ‡³ ì¸ë„ ì£¼ì‹">
                                <option value="RELIANCE.NS">RELIANCE.NS - ë¦´ë¼ì´ì–¸ìŠ¤ì¸ë”ìŠ¤íŠ¸ë¦¬</option>
                                <option value="TCS.NS">TCS.NS - íƒ€íƒ€ì»¨ì„¤í„´ì‹œì„œë¹„ìŠ¤</option>
                                <option value="HDFCBANK.NS">HDFCBANK.NS - HDFCì€í–‰</option>
                                <option value="INFY.NS">INFY.NS - ì¸í¬ì‹œìŠ¤</option>
                                <option value="HINDUNILVR.NS">HINDUNILVR.NS - íŒë‘ìŠ¤íƒ„ìœ ë‹ˆë ˆë²„</option>
                                <option value="ICICIBANK.NS">ICICIBANK.NS - ICICIì€í–‰</option>
                                <option value="SBIN.NS">SBIN.NS - ì¸ë„êµ­ë¦½ì€í–‰</option>
                                <option value="BHARTIARTL.NS">BHARTIARTL.NS - ë°”ë¥´í‹°ì—ì–´í…”</option>
                                <option value="ITC.NS">ITC.NS - ITC</option>
                                <option value="KOTAKBANK.NS">KOTAKBANK.NS - ì½”íƒë§ˆíŒë“œë¼ì€í–‰</option>
                                <option value="LT.NS">LT.NS - ë¼ìŠ¨ì•¤íˆ¬ë¸Œë¡œ</option>
                                <option value="ASIANPAINT.NS">ASIANPAINT.NS - ì•„ì‹œì•ˆí˜ì¸íŠ¸</option>
                                <option value="MARUTI.NS">MARUTI.NS - ë§ˆë£¨í‹°ìŠ¤ì¦ˆí‚¤</option>
                                <option value="AXISBANK.NS">AXISBANK.NS - ì•¡ì‹œìŠ¤ì€í–‰</option>
                                <option value="WIPRO.NS">WIPRO.NS - ìœ„í”„ë¡œ</option>
                                <option value="HCLTECH.NS">HCLTECH.NS - HCLí…Œí¬ë†€ë¡œì§€</option>
                                <option value="BAJFINANCE.NS">BAJFINANCE.NS - ë°”ì¦ˆíŒŒì´ë‚¸ìŠ¤</option>
                                <option value="SUNPHARMA.NS">SUNPHARMA.NS - ì„ íŒŒë§ˆ</option>
                                <option value="TECHM.NS">TECHM.NS - í…Œí¬ë§ˆíŒë“œë¼</option>
                                <option value="TITAN.NS">TITAN.NS - íƒ€ì´íƒ„</option>
                                <option value="ULTRACEMCO.NS">ULTRACEMCO.NS - ìš¸íŠ¸ë¼í…Œí¬ì‹œë©˜íŠ¸</option>
                                <option value="NESTLEIND.NS">NESTLEIND.NS - ë„¤ìŠ¬ë ˆì¸ë””ì•„</option>
                                <option value="POWERGRID.NS">POWERGRID.NS - íŒŒì›Œê·¸ë¦¬ë“œ</option>
                                <option value="NTPC.NS">NTPC.NS - NTPC</option>
                                <option value="COALINDIA.NS">COALINDIA.NS - ì½œì¸ë””ì•„</option>
                            </optgroup> <!-- UK Stocks -->
                            <optgroup label="ğŸ‡¬ğŸ‡§ ì˜êµ­ ì£¼ì‹">
                                <option value="AZN.L">AZN.L - ì•„ìŠ¤íŠ¸ë¼ì œë„¤ì¹´</option>
                                <option value="SHEL.L">SHEL.L - ì…¸</option>
                                <option value="ULVR.L">ULVR.L - ìœ ë‹ˆë ˆë²„</option>
                                <option value="BP.L">BP.L - BP</option>
                                <option value="HSBA.L">HSBA.L - HSBCí™€ë”©ìŠ¤</option>
                                <option value="GSK.L">GSK.L - GSK</option>
                                <option value="DGE.L">DGE.L - ë””ì•„ì§€ì˜¤</option>
                                <option value="RIO.L">RIO.L - ë¦¬ì˜¤í‹´í† </option>
                                <option value="BT-A.L">BT-A.L - BTê·¸ë£¹</option>
                                <option value="LLOY.L">LLOY.L - ë¡œì´ì¦ˆë±…í‚¹ê·¸ë£¹</option>
                                <option value="BARC.L">BARC.L - ë°”í´ë ˆì´ìŠ¤</option>
                                <option value="VOD.L">VOD.L - ë³´ë‹¤í°ê·¸ë£¹</option>
                                <option value="NWG.L">NWG.L - ë„¤ì´ì…˜ì™€ì´ë“œê·¸ë£¹</option>
                                <option value="GLEN.L">GLEN.L - ê¸€ë Œì½”ì–´</option>
                                <option value="TSCO.L">TSCO.L - í…ŒìŠ¤ì½”</option>
                            </optgroup>

                            <!-- Canadian Stocks -->
                            <optgroup label="ğŸ‡¨ğŸ‡¦ ìºë‚˜ë‹¤ ì£¼ì‹">
                                <option value="SHOP.TO">SHOP.TO - ì‡¼í”¼íŒŒì´</option>
                                <option value="RY.TO">RY.TO - ë¡œì—´ë±…í¬ì˜¤ë¸Œìºë‚˜ë‹¤</option>
                                <option value="TD.TO">TD.TO - í† ë¡ í† ë„ë¯¸ë‹ˆì–¸ì€í–‰</option>
                                <option value="BNS.TO">BNS.TO - ë±…í¬ì˜¤ë¸Œë…¸ë°”ìŠ¤ì½”ìƒ¤</option>
                                <option value="BMO.TO">BMO.TO - ë±…í¬ì˜¤ë¸Œëª¬íŠ¸ë¦¬ì˜¬</option>
                                <option value="CNR.TO">CNR.TO - ìºë‚˜ë””ì–¸ë‚´ì…”ë„ì² ë„</option>
                                <option value="CP.TO">CP.TO - ìºë‚˜ë””ì–¸í¼ì‹œí”½ì² ë„</option>
                                <option value="CNQ.TO">CNQ.TO - ìºë‚˜ë””ì–¸ë‚´ì¶”ëŸ´ë¦¬ì†ŒìŠ¤</option>
                                <option value="SU.TO">SU.TO - ì„ ì½”ì–´ì—ë„ˆì§€</option>
                                <option value="TRI.TO">TRI.TO - í†°ìŠ¨ë¡œì´í„°</option>
                                <option value="ENB.TO">ENB.TO - ì—”ë¸Œë¦¬ì§€</option>
                                <option value="WN.TO">WN.TO - ì¡°ì§€ì›¨ìŠ¤í„´</option>
                                <option value="CSU.TO">CSU.TO - ì»¨ìŠ¤í…”ë ˆì´ì…˜ì†Œí”„íŠ¸ì›¨ì–´</option>
                                <option value="ATD.TO">ATD.TO - ì•Œë¦¬ë©˜í…Œì´ì…˜ì¿ ì…°íƒ€ë“œ</option>
                                <option value="CCL-B.TO">CCL-B.TO - CCLì¸ë”ìŠ¤íŠ¸ë¦¬</option>
                            </optgroup>

                            <!-- French Stocks -->
                            <optgroup label="ğŸ‡«ğŸ‡· í”„ë‘ìŠ¤ ì£¼ì‹">
                                <option value="MC.PA">MC.PA - LVMH</option>
                                <option value="OR.PA">OR.PA - ë¡œë ˆì•Œ</option>
                                <option value="SAN.PA">SAN.PA - ì‚¬ë…¸í”¼</option>
                                <option value="ASML.PA">ASML.PA - ASMLí™€ë”©</option>
                                <option value="TTE.PA">TTE.PA - í† íƒˆì—ë„ˆì§€</option>
                                <option value="BNP.PA">BNP.PA - BNPíŒŒë¦¬ë°”</option>
                                <option value="ACA.PA">ACA.PA - í¬ë ˆë””íŠ¸ì•„ê·¸ë¦¬ì½œ</option>
                                <option value="AI.PA">AI.PA - ì—ì–´ë¦¬í€´ë“œ</option>
                                <option value="DG.PA">DG.PA - ë¹ˆì¹˜</option>
                                <option value="BN.PA">BN.PA - ë‹¤ë…¼</option>
                                <option value="CAP.PA">CAP.PA - ìº¡ì œë¯¸ë‹ˆ</option>
                                <option value="KER.PA">KER.PA - ì¼€ë§</option>
                                <option value="RNO.PA">RNO.PA - ë¥´ë…¸</option>
                                <option value="SU.PA">SU.PA - ìŠˆë‚˜ì´ë”ì¼ë ‰íŠ¸ë¦­</option>
                                <option value="AIR.PA">AIR.PA - ì—ì–´ë²„ìŠ¤</option>
                            </optgroup>

                            <!-- German Stocks -->
                            <optgroup label="ğŸ‡©ğŸ‡ª ë…ì¼ ì£¼ì‹">
                                <option value="SAP.DE">SAP.DE - SAP</option>
                                <option value="ASME.DE">ASME.DE - ASMLí™€ë”©</option>
                                <option value="SIE.DE">SIE.DE - ì§€ë©˜ìŠ¤</option>
                                <option value="ADS.DE">ADS.DE - ì•„ë””ë‹¤ìŠ¤</option>
                                <option value="ALV.DE">ALV.DE - ì•Œë¦¬ì•ˆì¸ </option>
                                <option value="BAS.DE">BAS.DE - BASF</option>
                                <option value="BMW.DE">BMW.DE - BMW</option>
                                <option value="DAI.DE">DAI.DE - ë©”ë¥´ì„¸ë°ìŠ¤ë²¤ì¸ ê·¸ë£¹</option>
                                <option value="VOW3.DE">VOW3.DE - í­ìŠ¤ë°”ê²</option>
                                <option value="DBK.DE">DBK.DE - ë„ì´ì²´ë±…í¬</option>
                                <option value="MUV2.DE">MUV2.DE - ë®Œí—¨ì¬ë³´í—˜</option>
                                <option value="DTE.DE">DTE.DE - ë„ì´ì²´í…”ë ˆì½¤</option>
                                <option value="LIN.DE">LIN.DE - ë¦°ë°</option>
                                <option value="BEI.DE">BEI.DE - ë°”ì´ì–´ìŠ¤ë„ë¥´í”„</option>
                                <option value="HEN3.DE">HEN3.DE - í—¨ì¼ˆ</option>
                            </optgroup>

                            <!-- Taiwanese Stocks -->
                            <optgroup label="ğŸ‡¹ğŸ‡¼ ëŒ€ë§Œ ì£¼ì‹">
                                <option value="2330.TW">2330.TW - ëŒ€ë§Œë°˜ë„ì²´(TSMC)</option>
                                <option value="2454.TW">2454.TW - ë¯¸ë””ì–´í…</option>
                                <option value="2317.TW">2317.TW - í›™í•˜ì´ì •ë°€</option>
                                <option value="2412.TW">2412.TW - ì¤‘í™”í…”ë ˆì½¤</option>
                                <option value="1303.TW">1303.TW - ë‚œì•¼í”Œë¼ìŠ¤í‹±</option>
                                <option value="2882.TW">2882.TW - ìºì„¸ì´ê¸ˆìœµ</option>
                                <option value="1326.TW">1326.TW - í¬ëª¨ì‚¬ì¼€ë¯¸ì»¬</option>
                                <option value="2408.TW">2408.TW - ë‚œì•¼í…Œí¬ë†€ë¡œì§€</option>
                                <option value="2881.TW">2881.TW - í‘¸ë³¸ê¸ˆìœµ</option>
                                <option value="3008.TW">3008.TW - ë¼ê°„ì •ë°€</option>
                                <option value="2303.TW">2303.TW - ìœ ë‚˜ì´í‹°ë“œë§ˆì´í¬ë¡œì¼ë ‰íŠ¸ë¡œë‹‰ìŠ¤</option>
                                <option value="2891.TW">2891.TW - CTBCê¸ˆìœµ</option>
                                <option value="6505.TW">6505.TW - í¬ëª¨ì‚¬í˜íŠ¸ë¡œì¼€ë¯¸ì»¬</option>
                                <option value="2207.TW">2207.TW - í˜¸íƒ€ì´ëª¨í„°</option>
                                <option value="2886.TW">2886.TW - ë©”ê°€ê¸ˆìœµ</option>
                            </optgroup>

                            <!-- Cryptocurrencies -->
                            <optgroup label="â‚¿ ì•”í˜¸í™”í">
                                <option value="BTC-USD">BTC-USD - ë¹„íŠ¸ì½”ì¸</option>
                                <option value="ETH-USD">ETH-USD - ì´ë”ë¦¬ì›€</option>
                                <option value="BNB-USD">BNB-USD - ë°”ì´ë‚¸ìŠ¤ì½”ì¸</option>
                                <option value="XRP-USD">XRP-USD - ë¦¬í”Œ</option>
                                <option value="ADA-USD">ADA-USD - ì¹´ë¥´ë‹¤ë…¸</option>
                                <option value="SOL-USD">SOL-USD - ì†”ë¼ë‚˜</option>
                                <option value="DOT-USD">DOT-USD - í´ì¹´ë‹·</option>
                                <option value="DOGE-USD">DOGE-USD - ë„ì§€ì½”ì¸</option>
                                <option value="AVAX-USD">AVAX-USD - ì•„ë°œë€ì²´</option>
                                <option value="SHIB-USD">SHIB-USD - ì‹œë°”ì´ëˆ„</option>
                                <option value="MATIC-USD">MATIC-USD - í´ë¦¬ê³¤</option>
                                <option value="LTC-USD">LTC-USD - ë¼ì´íŠ¸ì½”ì¸</option>
                                <option value="UNI-USD">UNI-USD - ìœ ë‹ˆìŠ¤ì™‘</option>
                                <option value="LINK-USD">LINK-USD - ì²´ì¸ë§í¬</option>
                                <option value="ATOM-USD">ATOM-USD - ì½”ìŠ¤ëª¨ìŠ¤</option>
                                <option value="TRX-USD">TRX-USD - íŠ¸ë¡ </option>
                                <option value="NEAR-USD">NEAR-USD - ë‹ˆì–´í”„ë¡œí† ì½œ</option>
                                <option value="ALGO-USD">ALGO-USD - ì•Œê³ ëœë“œ</option>
                                <option value="VET-USD">VET-USD - ë¹„ì²´ì¸</option>
                                <option value="ICP-USD">ICP-USD - ì¸í„°ë„·ì»´í“¨í„°</option>
                                <option value="FTM-USD">FTM-USD - íŒ¬í…€</option>
                                <option value="HBAR-USD">HBAR-USD - í—¤ë°ë¼</option>
                                <option value="FIL-USD">FIL-USD - íŒŒì¼ì½”ì¸</option>
                                <option value="ETC-USD">ETC-USD - ì´ë”ë¦¬ì›€í´ë˜ì‹</option>
                                <option value="XMR-USD">XMR-USD - ëª¨ë„¤ë¡œ</option>
                                <option value="XLM-USD">XLM-USD - ìŠ¤í…”ë¼</option>
                                <option value="BCH-USD">BCH-USD - ë¹„íŠ¸ì½”ì¸ìºì‹œ</option>
                                <option value="THETA-USD">THETA-USD - í…Œíƒ€</option>
                                <option value="SAND-USD">SAND-USD - ë”ìƒŒë“œë°•ìŠ¤</option>
                                <option value="MANA-USD">MANA-USD - ë””ì„¼íŠ¸ëŸ´ëœë“œ</option>
                                <option value="AXS-USD">AXS-USD - ì•¡ì‹œì¸í”¼ë‹ˆí‹°</option>
                                <option value="GRT-USD">GRT-USD - ë”ê·¸ë˜í”„</option>
                                <option value="ENJ-USD">ENJ-USD - ì—”ì§„ì½”ì¸</option>
                                <option value="CRV-USD">CRV-USD - ì»¤ë¸Œ</option>
                                <option value="SUSHI-USD">SUSHI-USD - ìŠ¤ì‹œìŠ¤ì™‘</option>
                            </optgroup>
                        </select>

                        <!-- Current Stock Info Display -->
                        <div id="stockInfo" class="hidden bg-tv-light/50 border border-tv-border rounded-lg p-6">
                            <div class="flex items-center justify-between">
                                <div>
                                    <h3 id="selectedStockName" class="text-xl font-semibold text-tv-text"></h3>
                                    <p id="selectedStockSymbol" class="text-tv-text-secondary"></p>
                                </div>
                                <div class="text-right">
                                    <p class="text-sm text-tv-text-secondary">í˜„ì¬ ê°€ê²©</p>
                                    <p id="currentStockPrice" class="text-3xl font-bold text-tv-text">$0.00</p>
                                    <p id="loadingPrice" class="text-sm text-tv-blue">
                                        <i class="fas fa-spinner fa-spin mr-1"></i>ê°€ê²© ë¡œë”© ì¤‘...
                                    </p>
                                </div>
                            </div>
                        </div>
                    </div>

                    <!-- Step 2: Interactive Chart Prediction -->
                    <div class="space-y-4">
                        <label class="block text-lg font-semibold text-tv-text">
                            <i class="fas fa-chart-line text-tv-green mr-2"></i>ì°¨íŠ¸ì—ì„œ ì˜ˆì¸¡í•˜ê¸°
                        </label>

                        <!-- Chart Instructions -->
                        <div class="bg-tv-blue/10 border border-tv-blue/30 rounded-lg p-4 mb-4">
                            <div class="flex items-start space-x-3">
                                <i class="fas fa-info-circle text-tv-blue mt-1"></i>
                                <div class="text-sm text-tv-text">
                                    <p class="font-semibold mb-2">ğŸ“Š ì°¨íŠ¸ ì˜ˆì¸¡ ë°©ë²•:</p>
                                    <ul class="space-y-1 text-tv-text-secondary">
                                        <li>â€¢ ì°¨íŠ¸ì—ì„œ ë¯¸ë˜ ë‚ ì§œë¡œ ì´ë™í•˜ì„¸ìš”</li>
                                        <li>â€¢ ì›í•˜ëŠ” ë‚ ì§œì™€ ê°€ê²© ìœ„ì¹˜ë¥¼ í´ë¦­/í„°ì¹˜í•˜ì„¸ìš”</li>
                                        <li>â€¢ ì—¬ëŸ¬ ë‚ ì§œì— ì˜ˆì¸¡ì ì„ ì¶”ê°€í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤</li>
                                        <li>â€¢ ëª¨ë°”ì¼ì—ì„œë„ í„°ì¹˜ë¡œ ì‰½ê²Œ ì˜ˆì¸¡ ê°€ëŠ¥í•©ë‹ˆë‹¤</li>
                                    </ul>
                                </div>
                            </div>
                        </div>

                        <!-- Real TradingView Style Chart Container -->
                        <div class="tradingview-chart bg-white border border-gray-200 rounded-lg overflow-hidden shadow-sm">
                            <!-- BOSS REQUIREMENT: SIMPLE KOREAN STYLE TOOLBAR -->
                            <div class="bg-white border-b border-gray-200 px-4 py-3">
                                <div class="flex items-center justify-between">
                                    <div class="flex items-center space-x-2">
                                        <span class="text-lg font-bold text-gray-800">ï¿½ ì£¼ì‹ì°¨íŠ¸</span>
                                    </div>
                                    <!-- BOSS REQUIREMENT: EXACTLY 5 BUTTONS ONLY -->
                                    <div class="flex items-center space-x-2">
                                        <button class="simple-time-btn px-4 py-2 text-sm border rounded hover:bg-blue-50" data-period="hourly" data-interval="1h">1ì‹œê°„</button>
                                        <button class="simple-time-btn px-4 py-2 text-sm border rounded hover:bg-blue-50" data-period="daily" data-interval="1d">ì¼ì¼</button>
                                        <button class="simple-time-btn px-4 py-2 text-sm border rounded hover:bg-blue-50" data-period="weekly" data-interval="1w">ì£¼ê°„</button>
                                        <button class="simple-time-btn px-4 py-2 text-sm border rounded hover:bg-blue-50 active" data-period="monthly" data-interval="1M">ì›”ê°„</button>
                                        <button class="simple-time-btn px-4 py-2 text-sm border rounded hover:bg-blue-50" data-period="yearly" data-interval="1Y">ë…„ê°„</button>
                                    </div>
                                </div>
                            </div>
                            
                            <!-- Real TradingView Style Price Header -->
                            <div class="bg-white px-4 py-3 border-b border-gray-100">
                                <div class="flex items-center justify-between">
                                    <div class="flex items-center space-x-4">
                                        <div class="flex items-center space-x-2">
                                            <span class="text-xs">ğŸ‡ºğŸ‡¸</span>
                                            <span class="font-medium">ë¯¸êµ­ ë‹¬ëŸ¬ / ëŒ€í•œë¯¼êµ­ ì›</span>
                                            <span class="text-xs">â€¢ 1ë¶„</span>
                                            <span class="text-xs">â€¢ ICE</span>
                                            <span class="w-2 h-2 bg-green-500 rounded-full"></span>
                                            <span class="text-xs">~</span>
                                        </div>
                                    </div>
                                    <span class="text-right text-sm font-bold">1,500.00</span>
                                </div>
                                <div class="flex items-center justify-between mt-2">
                                    <div class="flex items-center space-x-6 text-sm">
                                        <span>ì‹œ 1,390.21</span>
                                        <span>ê³  1,395.57</span>
                                        <span>ì € 1,390.21</span>
                                        <span>ì¢… 1,393.82</span>
                                        <span class="text-green-600">+3.60 (+0.26%)</span>
                                    </div>
                                    <div class="flex items-center space-x-4">
                                        <div class="text-xs">
                                            <span class="bg-red-100 text-red-700 px-2 py-1 rounded">1,393.82 ì…€</span>
                                            <span class="text-gray-500 mx-1">100</span>
                                            <span class="bg-blue-100 text-blue-700 px-2 py-1 rounded">1,394.82 ë°”ì´</span>
                                        </div>
                                    </div>
                                </div>
                                <div class="flex items-center justify-between mt-1">
                                    <span class="text-xs text-gray-500">ë³¼ë¥¨ 0</span>
                                    <span class="text-xs text-gray-500">1,480.00</span>
                                </div>
                            </div>
                            
                            <!-- TradingView Style Main Chart Area -->
                            <div class="relative bg-white">
                                <!-- Main Price Chart -->
                                <div class="relative touch-manipulation overflow-hidden chart-container" style="height: 600px; width: 100%">
                                    <canvas id="priceChart" class="w-full h-full touch-manipulation" style="touch-action: pan-x pan-y;"></canvas>
                                    <!-- TradingView Style Price Scale on Right (MANY LEVELS LIKE REFERENCE) -->
                                    <div class="absolute right-0 top-0 bottom-0 w-16 bg-white border-l border-gray-200 flex flex-col justify-between py-2 px-2" id="priceScaleContainer">
                                        <!-- Price levels will be dynamically populated by JavaScript -->
                                        <div class="text-xs text-gray-700 text-right font-medium" id="priceLevel_15">1398.00</div>
                                        <div class="text-xs text-gray-700 text-right font-medium" id="priceLevel_14">1396.00</div>
                                        <div class="text-xs text-gray-700 text-right font-medium" id="priceLevel_13">1394.00</div>
                                        <div class="text-xs text-gray-700 text-right font-medium" id="priceLevel_12">1392.00</div>
                                        <div class="text-xs text-gray-700 text-right font-medium" id="priceLevel_11">1390.00</div>
                                        <div class="text-xs text-gray-700 text-right font-medium" id="priceLevel_10">1388.00</div>
                                        <div class="text-xs text-gray-700 text-right font-medium" id="priceLevel_9">1386.00</div>
                                        <div class="text-xs text-gray-700 text-right font-medium" id="priceLevel_8">1384.00</div>
                                        <div class="text-xs text-gray-700 text-right font-medium" id="priceLevel_7">1382.00</div>
                                        <div class="text-xs text-gray-700 text-right font-medium" id="priceLevel_6">1380.00</div>
                                        <div class="text-xs text-gray-700 text-right font-medium" id="priceLevel_5">1378.00</div>
                                        <div class="text-xs text-gray-700 text-right font-medium" id="priceLevel_4">1376.00</div>
                                        <div class="text-xs text-gray-700 text-right font-medium" id="priceLevel_3">1374.00</div>
                                        <div class="text-xs text-gray-700 text-right font-medium" id="priceLevel_2">1372.00</div>
                                        <div class="text-xs text-gray-700 text-right font-medium" id="priceLevel_1">1370.00</div>
                                    </div>
                                </div>
                                
                                <!-- TradingView Style Volume Chart -->
                                <div class="relative border-t border-gray-200 bg-white" style="height: 150px;">
                                    <div class="absolute top-2 left-3 text-xs text-gray-600 font-medium">ë³¼ë¥¨</div>
                                    <canvas id="volumeChart" class="w-full h-full touch-manipulation" style="touch-action: pan-x pan-y;"></canvas>
                                    <!-- Volume Scale on Right -->
                                    <div class="absolute right-0 top-0 bottom-0 w-16 bg-white border-l border-gray-200 flex flex-col justify-between py-2 px-2">
                                        <div class="text-xs text-gray-700 text-right font-medium" id="maxVolume">1000</div>
                                        <div class="text-xs text-gray-700 text-right font-medium" id="minVolume">0</div>
                                    </div>
                                </div>
                                
                                <!-- TradingView Style Bottom Control Bar -->
                                <div class="tradingview-controls bg-gray-100 border-t border-gray-200 px-3 py-2">
                                    <div class="flex items-center justify-between">
                                        <div class="flex items-center space-x-3">
                                            <div class="flex space-x-1">
                                                <div class="w-3 h-2 bg-blue-500"></div>
                                                <div class="w-3 h-2 bg-red-500"></div>
                                                <div class="w-3 h-2 bg-blue-500"></div>
                                                <div class="w-3 h-2 bg-red-500"></div>
                                            </div>
                                            <span class="text-gray-600 text-sm">ì°¨íŠ¸ ë„¤ë¹„ê²Œì´ì…˜</span>
                                        </div>
                                        <div class="flex items-center space-x-2">
                                            <button class="px-3 py-1 bg-gray-200 hover:bg-gray-300 rounded text-sm text-gray-700" id="chartZoomOut">ì¶•ì†Œ</button>
                                            <button class="px-3 py-1 bg-gray-200 hover:bg-gray-300 rounded text-sm text-gray-700" id="chartZoomIn">í™•ëŒ€</button>
                                            <button class="px-3 py-1 bg-blue-600 hover:bg-blue-700 text-white rounded text-sm" id="chartReset">ì´ˆê¸°í™”</button>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- TradingView Style Date Labels Row (TOP - EXACT LIKE REFERENCE) -->
                                <div class="bg-white border-t border-gray-200 px-3 py-1">
                                    <div class="flex items-center justify-between relative">
                                        <!-- Date labels will be populated by JavaScript -->
                                        <div id="chartDateLabels" class="flex items-center justify-between w-full text-xs text-gray-600">
                                            <!-- Individual date numbers (2, 3, 4, 5, 8, 9, etc.) will appear here -->
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- BOSS REQUIREMENT: HIDDEN COMPLEX BUTTONS (TOO COMPLEX FOR USERS) -->
                                <div class="bg-gray-50 border-t border-gray-300 px-4 py-3 shadow-sm" style="display: none;">
                                    <div class="flex items-center justify-between">
                                        <!-- BOSS REQUIREMENT: PROMINENT TIME INTERVAL BUTTONS -->
                                        <div class="flex items-center space-x-2">
                                            <button class="time-interval-btn px-3 py-2 text-sm font-medium rounded" data-interval="1D">1D</button>
                                            <button class="time-interval-btn px-3 py-2 text-sm font-medium rounded" data-interval="5D">5D</button>
                                            <button class="time-interval-btn px-3 py-2 text-sm font-medium rounded" data-interval="1M">1M</button>
                                            <button class="time-interval-btn px-3 py-2 text-sm font-medium rounded" data-interval="3M">3M</button>
                                            <button class="time-interval-btn px-3 py-2 text-sm font-medium rounded" data-interval="6M">6M</button>
                                            <button class="time-interval-btn px-3 py-2 text-sm font-medium rounded" data-interval="YTD">YTD</button>
                                            <button class="time-interval-btn px-3 py-2 text-sm font-medium rounded" data-interval="1Y">1Y</button>
                                            <button class="time-interval-btn px-3 py-2 text-sm font-medium rounded" data-interval="5Y">5Y</button>
                                            <button class="time-interval-btn px-3 py-2 text-sm font-medium rounded active" data-interval="ì „ì²´">ì „ì²´</button>
                                            
                                            <!-- Chart Type Selector -->
                                            <div class="border-l border-gray-300 ml-2 pl-2">
                                                <button class="chart-type-btn px-2 py-1 text-xs text-gray-600 hover:bg-gray-100 rounded active" data-type="candlestick" title="ìº”ë“¤ìŠ¤í‹± ì°¨íŠ¸">
                                                    ğŸ•¯ï¸
                                                </button>
                                            </div>
                                        </div>
                                        
                                        <!-- Right: Real-time Clock (EXACT LIKE REFERENCE) -->
                                        <div class="flex items-center space-x-2 text-xs text-gray-600">
                                            <span id="currentTime">15:30:05 UTC+9</span>
                                        </div>
                                    </div>
                                </div>
                                
                                <!-- TradingView Style Time Controls -->
                                <div class="bg-gray-200 border-t border-gray-300 px-3 py-2">
                                    <div class="flex items-center justify-between">
                                        <span class="text-gray-700 text-sm font-medium">ì‹œê°„ ì´ë™:</span>
                                        <div class="flex items-center space-x-3 flex-1 mx-4">
                                            <button id="scrollToPast" class="px-2 py-1 bg-gray-300 hover:bg-gray-400 text-gray-700 rounded text-sm">â† ê³¼ê±°</button>
                                            <div class="flex-1 flex items-center space-x-2">
                                                <span class="text-gray-600 text-xs">ê³¼ê±°</span>
                                                <input type="range" id="chartTimeScrollbar" 
                                                       class="flex-1 h-2 bg-gray-400 rounded-lg appearance-none cursor-pointer"
                                                       min="0" max="100" value="70" step="1">
                                                <span class="text-gray-600 text-xs">ë¯¸ë˜</span>
                                            </div>
                                            <button id="scrollToFuture" class="px-2 py-1 bg-gray-300 hover:bg-gray-400 text-gray-700 rounded text-sm">ë¯¸ë˜ â†’</button>
                                        </div>
                                        <div id="timePosition" class="text-gray-700 text-sm font-medium min-w-16 text-center">í˜„ì¬</div>
                                    </div>
                                </div>
                            </div>
                        </div>

                        <!-- Hidden elements to prevent JavaScript errors -->
                        <div style="display: none;">
                            <input type="text" id="stockSearchInput">
                            <select id="chartTimeRange"></select>
                            <button id="clearPredictions"></button>
                            <button id="resetZoom"></button>
                            <input type="checkbox" id="showPredictionCheckbox">
                            <input type="checkbox" id="showVolume">
                            <button id="deletePredictionBtn"></button>
                            <div id="chartToggles"></div>
                            <div id="toolbar"></div>
                            <div id="loadingSpinner"></div>
                            <div id="errorMessage"></div>
                            <div id="drawingTools"></div>
                            <button id="fitChart"></button>
                            <div id="currentPriceDisplay"></div>
                            <div id="stockInfo"></div>
                            <input type="range" id="chartScrollbar" min="0" max="100" value="100">
                            <div id="chartLoading"></div>
                            <div id="noStockSelected"></div>
                        </div>

                        <!-- Predictions Summary -->
                        <div id="predictionsPanel" class="hidden bg-tv-light/30 border border-tv-border rounded-lg p-4">
                            <div class="flex items-center justify-between mb-3">
                                <h4 class="font-semibold text-tv-text">
                                    <i class="fas fa-list text-tv-green mr-2"></i>ì„¤ì •ëœ ì˜ˆì¸¡
                                </h4>
                                <span id="predictionCount" class="text-sm text-tv-text-secondary">0ê°œ ì˜ˆì¸¡</span>
                            </div>
                            <div id="predictionsList" class="space-y-2 max-h-32 overflow-y-auto">
                                <!-- Predictions will be dynamically added here -->
                            </div>
                        </div>
                    </div>

                    <!-- Optional: Analysis/Reasoning -->
                    <div class="space-y-4">
                        <label class="block text-lg font-semibold text-tv-text">
                            <i class="fas fa-lightbulb text-orange-500 mr-2"></i>ì˜ˆì¸¡ ê·¼ê±° (ì„ íƒì‚¬í•­)
                        </label>

                        <textarea id="predictionReason" name="reasoning" rows="3"
                            class="w-full px-4 py-3 bg-tv-light border border-tv-border rounded-lg text-tv-text focus:ring-2 focus:ring-tv-blue focus:border-tv-blue transition-all resize-none"
                            placeholder="ì˜ˆì¸¡ì˜ ê·¼ê±°ë‚˜ ë¶„ì„ ë‚´ìš©ì„ ê°„ë‹¨íˆ ì‘ì„±í•´ì£¼ì„¸ìš” (ì„ íƒì‚¬í•­)"></textarea>
                    </div>

                    <!-- Submit Button -->
                    <div class="pt-6">
                        <button type="submit" id="submitPrediction"
                            class="w-full bg-gradient-to-r from-tv-blue to-blue-600 hover:from-blue-600 hover:to-tv-blue text-white font-bold py-4 px-8 rounded-lg transition-all duration-300 transform hover:scale-[1.02] hover:shadow-lg hover:shadow-tv-blue/20 disabled:opacity-50 disabled:cursor-not-allowed disabled:transform-none disabled:hover:shadow-none">
                            <i class="fas fa-rocket mr-2"></i>
                            <span id="submitButtonText">ì˜ˆì¸¡ ë°œí–‰í•˜ê¸°</span>
                        </button>
                    </div>

                </form>
            </div>

            <!-- Success Message -->
            <div id="successMessage"
                class="hidden mt-8 bg-tv-green/20 border border-tv-green/30 rounded-lg p-6 text-center">
                <div class="flex items-center justify-center mb-4">
                    <div class="w-16 h-16 bg-tv-green/20 rounded-full flex items-center justify-center">
                        <i class="fas fa-check text-tv-green text-2xl"></i>
                    </div>
                </div>
                <h3 class="text-xl font-bold text-tv-green mb-2">ì˜ˆì¸¡ì´ ì„±ê³µì ìœ¼ë¡œ ë°œí–‰ë˜ì—ˆìŠµë‹ˆë‹¤!</h3>
                <p class="text-tv-text-secondary mb-4">ì˜ˆì¸¡ì´ ì €ì¥ë˜ì—ˆìœ¼ë©° ë‹¤ë¥¸ ì‚¬ìš©ìë“¤ì´ ë³¼ ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
                <div class="flex gap-4 justify-center">
                    <button onclick="resetForm()"
                        class="bg-tv-blue hover:bg-blue-600 text-white px-6 py-2 rounded-lg transition-colors">
                        ìƒˆ ì˜ˆì¸¡ ì‘ì„±
                    </button>
                    <a href="my-predictions.html"
                        class="bg-tv-green hover:bg-green-600 text-white px-6 py-2 rounded-lg transition-colors">
                        ë‚´ ì˜ˆì¸¡ ë³´ê¸°
                    </a>
                </div>
            </div>

            <!-- API Status Panel -->
            <div id="apiStatusPanel" class="mt-8 bg-tv-card border border-tv-border rounded-lg overflow-hidden">
                <div class="bg-tv-light border-b border-tv-border p-4 flex items-center justify-between">
                    <h3 class="text-lg font-semibold text-tv-text">
                        <i class="fas fa-server text-tv-blue mr-2"></i>API ìƒíƒœ
                    </h3>
                    <button onclick="checkApiStatus()"
                        class="px-3 py-1 bg-tv-blue/20 border border-tv-blue/30 text-tv-blue rounded text-sm hover:bg-tv-blue/30 transition-colors">
                        <i class="fas fa-refresh mr-1"></i>ìƒˆë¡œê³ ì¹¨
                    </button>
                </div>
                <div class="p-4">
                    <div id="apiStatusContent" class="space-y-3">
                        <div class="text-center text-tv-text-secondary py-4">
                            <i class="fas fa-spinner fa-spin text-tv-blue text-xl mb-2"></i>
                            <p>API ìƒíƒœ í™•ì¸ ì¤‘...</p>
                        </div>
                    </div>
                </div>
            </div>

        </div>
    </main>

    <!-- JavaScript -->
    <script>
        // ğŸ›ï¸ PURE KOREAN CANDLESTICK CHART IMPLEMENTATION
        let koreanChart = null;
        let chartCanvas = null;
        let chartCtx = null;
        let chartData = [];

        // Initialize Korean-style candlestick chart with mobile optimization
        function initializeKoreanChart() {
            console.log('ğŸ›ï¸ Creating Pure Korean Candlestick Chart with Mobile Support...');
            
            chartCanvas = document.getElementById('priceChart');
            if (!chartCanvas) {
                console.error('âŒ Canvas element #priceChart not found');
                return false;
            }
            
            chartCtx = chartCanvas.getContext('2d');
            
            // Mobile-responsive canvas sizing
            const container = chartCanvas.parentElement;
            const isMobile = window.innerWidth <= 640; // Tailwind 'sm' breakpoint
            
            // Set canvas size with mobile considerations
            chartCanvas.width = container.clientWidth;
            chartCanvas.height = container.clientHeight;
            
            // Dynamic padding based on screen size
            const padding = isMobile 
                ? { top: 15, right: 50, bottom: 30, left: 30 }
                : { top: 20, right: 80, bottom: 40, left: 40 };
            
            // BOSS REQUIREMENT: Make Korean chart globally accessible for zoom functionality
            koreanChart = {
                canvas: chartCanvas,
                ctx: chartCtx,
                data: [],
                width: chartCanvas.width,
                height: chartCanvas.height,
                padding: padding,
                hoverPoint: null,
                timeInterval: '1d', // Default interval (1d, 1wk, 1mo)
                isMobile: isMobile,
                zoomLevel: 1.0, // Add zoom level to Korean chart
                scrollOffset: 0, // Add scroll offset to Korean chart
                
                // Update chart with new data - show more candles for proper spacing like reference
                updateData: function(candlestickData) {
                    this.data = candlestickData.slice(-30); // Show last 30 candles for proper spacing
                    this.draw();
                    this.setupEventListeners();
                },
                
                // Update time interval
                setTimeInterval: function(interval) {
                    this.timeInterval = interval;
                    this.draw(); // Redraw with new interval label
                },
                
                // Setup mouse events for tooltip and prediction interaction
                setupEventListeners: function() {
                    const chart = this;
                    
                    // Remove existing listeners
                    this.canvas.removeEventListener('mousemove', this.canvas.onmousemove);
                    this.canvas.removeEventListener('mouseout', this.canvas.onmouseout);
                    this.canvas.removeEventListener('click', this.canvas.onclick);
                    
                    // Mouse move handler for tooltips and hover effects
                    this.canvas.onmousemove = function(e) {
                        const rect = chart.canvas.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const y = e.clientY - rect.top;
                        
                        chart.handleMouseMove(x, y);
                    };
                    
                    // Mouse out handler
                    this.canvas.onmouseout = function() {
                        chart.hoverPoint = null;
                        chart.hoveredPrediction = null;
                        chart.draw();
                        hidePredictionDeleteButton();
                    };
                    
                    // Click handler for creating predictions
                    this.canvas.onclick = function(e) {
                        const rect = chart.canvas.getBoundingClientRect();
                        const x = e.clientX - rect.left;
                        const y = e.clientY - rect.top;
                        
                        chart.handleChartClick(x, y);
                    };
                    
                    // Add mouse and touch listeners for mobile support
                    this.canvas.addEventListener('mousemove', this.canvas.onmousemove);
                    this.canvas.addEventListener('mouseout', this.canvas.onmouseout);
                    this.canvas.addEventListener('click', this.canvas.onclick);
                    
                    // Touch event handlers for mobile
                    this.canvas.addEventListener('touchstart', (e) => {
                        e.preventDefault();
                        const touch = e.touches[0];
                        const rect = this.canvas.getBoundingClientRect();
                        const x = touch.clientX - rect.left;
                        const y = touch.clientY - rect.top;
                        this.handleMouseMove(x, y);
                    });
                    
                    this.canvas.addEventListener('touchmove', (e) => {
                        e.preventDefault();
                        const touch = e.touches[0];
                        const rect = this.canvas.getBoundingClientRect();
                        const x = touch.clientX - rect.left;
                        const y = touch.clientY - rect.top;
                        this.handleMouseMove(x, y);
                    });
                    
                    this.canvas.addEventListener('touchend', (e) => {
                        e.preventDefault();
                        if (e.changedTouches.length > 0) {
                            const touch = e.changedTouches[0];
                            const rect = this.canvas.getBoundingClientRect();
                            const x = touch.clientX - rect.left;
                            const y = touch.clientY - rect.top;
                            this.handleChartClick(x, y);
                        }
                    });
                },
                
                // Handle mouse movement for tooltips and prediction hover
                handleMouseMove: function(mouseX, mouseY) {
                    if (!this.data || this.data.length === 0) return;
                    
                    const { padding, width, height } = this;
                    const chartArea = {
                        left: padding.left,
                        top: padding.top,
                        right: width - padding.right,
                        bottom: height - padding.bottom,
                        width: width - padding.left - padding.right,
                        height: height - padding.top - padding.bottom
                    };
                    
                    // Check if mouse is in chart area
                    if (mouseX < chartArea.left || mouseX > chartArea.right || 
                        mouseY < chartArea.top || mouseY > chartArea.bottom) {
                        this.hoverPoint = null;
                        this.hoveredPrediction = null;
                        this.draw();
                        return;
                    }
                    
                    // Check for prediction point hover first
                    let hoveredPrediction = null;
                    if (predictions && predictions.length > 0) {
                        hoveredPrediction = this.findHoveredPrediction(mouseX, mouseY, chartArea);
                    }
                    
                    if (hoveredPrediction) {
                        this.hoveredPrediction = hoveredPrediction;
                        this.hoverPoint = null;
                        this.canvas.style.cursor = 'pointer';
                        showPredictionDeleteButton(mouseX, mouseY, hoveredPrediction);
                    } else {
                        this.hoveredPrediction = null;
                        hidePredictionDeleteButton();
                        
                        // Find closest candle for regular tooltip
                        const candleCount = this.data.length;
                        const candleSpacing = chartArea.width / candleCount;
                        let closestIndex = Math.floor((mouseX - chartArea.left) / candleSpacing);
                        
                        // Ensure valid index
                        closestIndex = Math.max(0, Math.min(closestIndex, this.data.length - 1));
                        
                        // Update hover point
                        this.hoverPoint = {
                            index: closestIndex,
                            data: this.data[closestIndex]
                        };
                        
                        this.canvas.style.cursor = 'crosshair';
                    }
                    
                    // Redraw with tooltip/hover effects
                    this.draw();
                },
                
                // Find if mouse is hovering over a prediction point
                findHoveredPrediction: function(mouseX, mouseY, chartArea) {
                    if (!predictions || predictions.length === 0) return null;
                    
                    for (const prediction of predictions) {
                        const predictionDate = new Date(prediction.date);
                        const predictionPrice = prediction.price;
                        
                        // Calculate prediction point position
                        const { x, y } = this.getPredictionPosition(predictionDate, predictionPrice, chartArea);
                        
                        // Check if mouse is within prediction point area (20px radius)
                        const distance = Math.sqrt(Math.pow(mouseX - x, 2) + Math.pow(mouseY - y, 2));
                        if (distance <= 20) {
                            return prediction;
                        }
                    }
                    
                    return null;
                },
                
                // Get prediction point position on chart with extended future area
                getPredictionPosition: function(date, price, chartArea) {
                    // For future dates, calculate position based on extended time range
                    const dataStartTime = this.data[0] ? new Date(this.data[0].x).getTime() : Date.now();
                    const dataEndTime = this.data[this.data.length - 1] ? new Date(this.data[this.data.length - 1].x).getTime() : Date.now();
                    const totalTimeRange = dataEndTime - dataStartTime;
                    const extendedTimeRange = totalTimeRange * 2.0; // Match the click conversion
                    
                    const predictionTime = date.getTime();
                    const timeRatio = (predictionTime - dataStartTime) / extendedTimeRange;
                    const x = chartArea.left + (timeRatio * chartArea.width);
                    
                    // Calculate Y position based on price range
                    const prices = this.data.map(d => [d.h, d.l, d.o, d.c]).flat();
                    const minPrice = Math.min(...prices);
                    const maxPrice = Math.max(...prices);
                    const priceRange = maxPrice - minPrice;
                    const margin = priceRange * 0.1;
                    
                    const y = chartArea.top + ((maxPrice + margin - price) / (priceRange + margin * 2)) * chartArea.height;
                    
                    return { x, y };
                },
                
                // Handle chart click for prediction creation
                handleChartClick: function(mouseX, mouseY) {
                    const { padding, width, height } = this;
                    const chartArea = {
                        left: padding.left,
                        top: padding.top,
                        right: width - padding.right,
                        bottom: height - padding.bottom,
                        width: width - padding.left - padding.right,
                        height: height - padding.top - padding.bottom
                    };
                    
                    // Check if click is in chart area
                    if (mouseX < chartArea.left || mouseX > chartArea.right || 
                        mouseY < chartArea.top || mouseY > chartArea.bottom) {
                        return;
                    }
                    
                    // Convert click position to date and price
                    const { date, price } = this.convertClickToDatePrice(mouseX, mouseY, chartArea);
                    
                    // Allow predictions for current and future dates (Korean style - more permissive)
                    const today = new Date();
                    today.setHours(0, 0, 0, 0);
                    const clickDate = new Date(date);
                    clickDate.setHours(0, 0, 0, 0);
                    
                    if (clickDate < today) {
                        showMessage('ì˜¤ëŠ˜ ë˜ëŠ” ë¯¸ë˜ ë‚ ì§œì— ì˜ˆì¸¡ì„ ì„¤ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.', 'warning');
                        return;
                    }
                    
                    // Add or update prediction
                    createOrUpdatePrediction(date, price);
                },
                
                // Convert mouse click to date and price with proper future date extension
                convertClickToDatePrice: function(mouseX, mouseY, chartArea) {
                    // Calculate date based on extended time range for future predictions
                    const dataStartTime = this.data[0] ? new Date(this.data[0].x).getTime() : Date.now();
                    const dataEndTime = this.data[this.data.length - 1] ? new Date(this.data[this.data.length - 1].x).getTime() : Date.now();
                    const totalTimeRange = dataEndTime - dataStartTime;
                    
                    // Extend chart area significantly for future dates (like Korean charts)
                    const futureExtensionRatio = 2.0; // Show 100% more time into future
                    const extendedTimeRange = totalTimeRange * futureExtensionRatio;
                    
                    const timeRatio = (mouseX - chartArea.left) / chartArea.width;
                    const clickTime = dataStartTime + (timeRatio * extendedTimeRange);
                    const date = new Date(clickTime);
                    
                    // Calculate price based on price range
                    const prices = this.data.map(d => [d.h, d.l, d.o, d.c]).flat();
                    const minPrice = Math.min(...prices);
                    const maxPrice = Math.max(...prices);
                    const priceRange = maxPrice - minPrice;
                    const margin = priceRange * 0.1;
                    
                    const priceRatio = (chartArea.bottom - mouseY) / chartArea.height;
                    const price = (minPrice - margin) + (priceRatio * (priceRange + margin * 2));
                    
                    return { date, price };
                },
                
                // Draw the Korean-style candlestick chart
                draw: function() {
                    if (!this.data || this.data.length === 0) return;
                    
                    const ctx = this.ctx;
                    const { width, height, padding } = this;
                    
                    // Clear canvas
                    ctx.clearRect(0, 0, width, height);
                    
                    // Chart area
                    const chartArea = {
                        left: padding.left,
                        top: padding.top,
                        right: width - padding.right,
                        bottom: height - padding.bottom,
                        width: width - padding.left - padding.right,
                        height: height - padding.top - padding.bottom
                    };
                    
                    // INSTANT ZOOM CALCULATIONS
                    const currentZoom = globalZoomLevel || this.zoomLevel || 1.0;
                    const currentScroll = globalScrollOffset || this.scrollOffset || 0;
                    
                    const baseCandles = 25;
                    const maxCandles = Math.max(5, Math.min(50, Math.floor(baseCandles / currentZoom)));
                    const limitedData = this.data.slice(-maxCandles - currentScroll, this.data.length - currentScroll);
                    const candleCount = limitedData.length;
                    const candleSpacing = chartArea.width / candleCount;
                    
                    // INSTANT CANDLE WIDTH CALCULATION  
                    let candleWidth = Math.floor(candleSpacing * currentZoom);
                    const minCandleWidth = Math.max(3, 15 * currentZoom);
                    const maxCandleWidth = Math.max(8, 60 * currentZoom);
                    
                    candleWidth = Math.max(candleWidth, minCandleWidth);
                    candleWidth = Math.min(candleWidth, maxCandleWidth);
                    const wickWidth = Math.max(1, Math.floor(candleWidth / 8));
                    
                    // Calculate price range for positioning
                    const prices = this.data.map(d => [d.h, d.l, d.o, d.c]).flat();
                    const minPrice = Math.min(...prices);
                    const maxPrice = Math.max(...prices);
                    const priceRange = maxPrice - minPrice;
                    const margin = priceRange * 0.1;
                    
                    // White background
                    ctx.fillStyle = '#FFFFFF';
                    ctx.fillRect(0, 0, width, height);
                    
                    // INSTANT CANDLESTICK DRAWING
                    limitedData.forEach((candle, index) => {
                        const x = chartArea.left + (index * candleSpacing) + (candleSpacing / 2);
                        
                        // Map prices to Y coordinates
                        const high = chartArea.top + ((maxPrice + margin - candle.h) / (priceRange + margin * 2)) * chartArea.height;
                        const low = chartArea.top + ((maxPrice + margin - candle.l) / (priceRange + margin * 2)) * chartArea.height;
                        const open = chartArea.top + ((maxPrice + margin - candle.o) / (priceRange + margin * 2)) * chartArea.height;
                        const close = chartArea.top + ((maxPrice + margin - candle.c) / (priceRange + margin * 2)) * chartArea.height;
                        
                        // Colors
                        const isUp = candle.c >= candle.o;
                        const bodyColor = isUp ? '#FF0000' : '#0066FF';
                        const wickColor = isUp ? '#CC0000' : '#0044CC';
                        
                        // Draw wick
                        ctx.strokeStyle = wickColor;
                        ctx.lineWidth = wickWidth;
                        ctx.beginPath();
                        ctx.moveTo(x, high);
                        ctx.lineTo(x, low);
                        ctx.stroke();
                        
                        // Draw body
                        const bodyTop = Math.min(open, close);
                        const bodyHeight = Math.max(Math.abs(close - open), 3);
                        
                        ctx.fillStyle = bodyColor;
                        ctx.fillRect(x - candleWidth / 2, bodyTop, candleWidth, bodyHeight);
                        
                        ctx.strokeStyle = bodyColor;
                        ctx.lineWidth = 1;
                        ctx.strokeRect(x - candleWidth / 2, bodyTop, candleWidth, bodyHeight);
                    });
                    
                    // Draw prediction points on top of candlesticks
                    this.drawPredictionPoints(chartArea, minPrice, maxPrice, priceRange, margin);
                    
                    // Draw tooltip if we have a hover point
                    if (this.hoverPoint) {
                        const candle = this.hoverPoint.data;
                        const index = this.hoverPoint.index;
                        const x = chartArea.left + (index * candleSpacing) + (candleSpacing / 2);
                        const y = chartArea.top;
                        this.drawTooltip(x, y - 10, candle);
                    }
                    
                    // Highlight hovered prediction point
                    if (this.hoveredPrediction) {
                        this.drawHoveredPrediction(chartArea, minPrice, maxPrice, priceRange, margin);
                    }
                    
                    // Draw price scale
                    this.drawPriceScale(chartArea, minPrice, maxPrice, priceRange, margin);
                },
                
                // Draw prediction points
                drawPredictionPoints: function(chartArea, minPrice, maxPrice, priceRange, margin) {
                    if (!predictions || predictions.length === 0) return;
                    
                    const ctx = this.ctx;
                    
                    predictions.forEach(prediction => {
                        const predictionDate = new Date(prediction.date);
                        const predictionPrice = prediction.price;
                        
                        const { x, y } = this.getPredictionPosition(predictionDate, predictionPrice, chartArea);
                        
                        // Skip if prediction point is outside visible area
                        if (x < chartArea.left || x > chartArea.right || y < chartArea.top || y > chartArea.bottom) {
                            return;
                        }
                        
                        // Draw prediction point
                        ctx.fillStyle = '#FF6B35'; // Orange color for predictions
                        ctx.strokeStyle = '#FF4500';
                        ctx.lineWidth = 3;
                        
                        // Draw circle
                        ctx.beginPath();
                        ctx.arc(x, y, 8, 0, 2 * Math.PI);
                        ctx.fill();
                        ctx.stroke();
                        
                        // Draw inner dot
                        ctx.fillStyle = '#FFFFFF';
                        ctx.beginPath();
                        ctx.arc(x, y, 3, 0, 2 * Math.PI);
                        ctx.fill();
                    });
                },
                
                // Draw highlighted hovered prediction
                drawHoveredPrediction: function(chartArea, minPrice, maxPrice, priceRange, margin) {
                    if (!this.hoveredPrediction) return;
                    
                    const ctx = this.ctx;
                    const predictionDate = new Date(this.hoveredPrediction.date);
                    const predictionPrice = this.hoveredPrediction.price;
                    
                    const { x, y } = this.getPredictionPosition(predictionDate, predictionPrice, chartArea);
                    
                    // Draw enlarged highlighted prediction point
                    ctx.fillStyle = '#FF6B35';
                    ctx.strokeStyle = '#FFFFFF';
                    ctx.lineWidth = 4;
                    
                    // Draw larger circle
                    ctx.beginPath();
                    ctx.arc(x, y, 12, 0, 2 * Math.PI);
                    ctx.fill();
                    ctx.stroke();
                    
                    // Draw inner dot
                    ctx.fillStyle = '#FFFFFF';
                    ctx.beginPath();
                    ctx.arc(x, y, 4, 0, 2 * Math.PI);
                    ctx.fill();
                    
                    // Draw pulsing effect
                    ctx.strokeStyle = 'rgba(255, 107, 53, 0.5)';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.arc(x, y, 16, 0, 2 * Math.PI);
                    ctx.stroke();
                },
                
                // Get Korean interval name
                getIntervalName: function() {
                    switch(this.timeInterval) {
                        case '1d': return 'ì¼ì¼ (Daily)';
                        case '1wk': return 'ì£¼ê°„ (Weekly)';
                        case '1mo': return 'ì›”ê°„ (Monthly)';
                        default: return 'ì¼ì¼ (Daily)';
                    }
                },
                
                // BOSS REQUIREMENT: Add zoom functionality to Korean chart
                setZoom: function(newZoomLevel) {
                    this.zoomLevel = Math.max(0.1, Math.min(5.0, newZoomLevel));
                    console.log(`ğŸ” Korean Chart Zoom Updated: ${this.zoomLevel.toFixed(2)}`);
                    this.draw(); // Redraw with new zoom
                },
                
                // BOSS REQUIREMENT: Add scroll functionality to Korean chart
                setScroll: function(newScrollOffset) {
                    this.scrollOffset = Math.max(0, Math.min(this.data.length - 10, newScrollOffset));
                    console.log(`ğŸ“œ Korean Chart Scroll Updated: ${this.scrollOffset}`);
                    this.draw(); // Redraw with new scroll
                },
                
                // Update date labels in HTML (EXACT like TradingView reference)
                updateDateLabelsHTML: function() {
                    const dateLabelsContainer = document.getElementById('chartDateLabels');
                    if (!dateLabelsContainer || !this.data || this.data.length === 0) return;
                    
                    // Clear existing labels
                    dateLabelsContainer.innerHTML = '';
                    
                    // Create date labels for each candlestick
                    const fragment = document.createDocumentFragment();
                    
                    this.data.forEach((candle, index) => {
                        const date = new Date(candle.x);
                        
                        // Format date EXACTLY like reference: just day numbers (2, 3, 4, 5, 8, 9, etc.)
                        let dateLabel;
                        if (this.timeInterval === '1mo') {
                            dateLabel = `${date.getMonth()+1}.${date.getFullYear().toString().slice(-2)}`;
                        } else if (this.timeInterval === '1wk') {
                            dateLabel = `${date.getMonth()+1}/${date.getDate()}`;
                        } else {
                            // Daily format EXACTLY like reference: just the day number (2, 3, 4, 5, etc.)
                            dateLabel = `${date.getDate()}`;
                        }
                        
                        // Create span element for each date
                        const dateSpan = document.createElement('span');
                        dateSpan.textContent = dateLabel;
                        dateSpan.className = 'text-gray-600 text-xs font-medium';
                        
                        fragment.appendChild(dateSpan);
                    });
                    
                    // Add month indicator at the end like reference: "10ì›”"
                    if (this.data.length > 0) {
                        const lastCandle = this.data[this.data.length - 1];
                        const lastDate = new Date(lastCandle.x);
                        
                        const monthSpan = document.createElement('span');
                        monthSpan.textContent = `${lastDate.getMonth() + 1}ì›”`;
                        monthSpan.className = 'text-gray-700 text-xs font-bold ml-2';
                        
                        fragment.appendChild(monthSpan);
                    }
                    
                    dateLabelsContainer.appendChild(fragment);
                    
                    console.log(`âœ… Updated ${this.data.length} date labels in HTML: ${this.data.map(d => new Date(d.x).getDate()).join(', ')}`);
                },
                
                // Draw tooltip with OHLC data in Korean
                drawTooltip: function(x, y, candle) {
                    const ctx = this.ctx;
                    const date = new Date(candle.x);
                    const formattedDate = date.toLocaleDateString('ko-KR', { 
                        year: 'numeric', 
                        month: 'long', 
                        day: 'numeric',
                        weekday: 'long'
                    });
                    
                    const isUp = candle.c >= candle.o;
                    const changeAmount = (candle.c - candle.o).toFixed(2);
                    const changePercent = ((candle.c - candle.o) / candle.o * 100).toFixed(2);
                    const changeColor = isUp ? '#FF0000' : '#0066FF';
                    const changeSymbol = isUp ? 'â–²' : 'â–¼';
                    
                    // Format tooltip content
                    const lines = [
                        formattedDate,
                        `ì‹œê°€ (Open): ${candle.o.toFixed(2)}`,
                        `ê³ ê°€ (High): ${candle.h.toFixed(2)}`,
                        `ì €ê°€ (Low): ${candle.l.toFixed(2)}`,
                        `ì¢…ê°€ (Close): ${candle.c.toFixed(2)}`,
                        `ë³€ë™: ${changeSymbol} ${Math.abs(changeAmount)} (${changePercent}%)`
                    ];
                    
                    // Calculate tooltip dimensions
                    ctx.font = '12px Arial';
                    const lineHeight = 18;
                    const padding = 10;
                    const maxWidth = lines.reduce((max, line) => Math.max(max, ctx.measureText(line).width), 0);
                    const tooltipWidth = maxWidth + padding * 2;
                    const tooltipHeight = lineHeight * lines.length + padding * 2;
                    
                    // Position tooltip to remain within canvas
                    let tooltipX = x - tooltipWidth / 2;
                    if (tooltipX < 0) tooltipX = 0;
                    if (tooltipX + tooltipWidth > this.width) tooltipX = this.width - tooltipWidth;
                    
                    let tooltipY = y - tooltipHeight - 5;
                    if (tooltipY < 0) tooltipY = y + 5; // Show below if not enough space above
                    
                    // Draw tooltip background with Korean-style border
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.95)';
                    ctx.strokeStyle = '#444444';
                    ctx.lineWidth = 2;
                    
                    // Draw rounded rectangle
                    const radius = 5;
                    ctx.beginPath();
                    ctx.moveTo(tooltipX + radius, tooltipY);
                    ctx.lineTo(tooltipX + tooltipWidth - radius, tooltipY);
                    ctx.quadraticCurveTo(tooltipX + tooltipWidth, tooltipY, tooltipX + tooltipWidth, tooltipY + radius);
                    ctx.lineTo(tooltipX + tooltipWidth, tooltipY + tooltipHeight - radius);
                    ctx.quadraticCurveTo(tooltipX + tooltipWidth, tooltipY + tooltipHeight, tooltipX + tooltipWidth - radius, tooltipY + tooltipHeight);
                    ctx.lineTo(tooltipX + radius, tooltipY + tooltipHeight);
                    ctx.quadraticCurveTo(tooltipX, tooltipY + tooltipHeight, tooltipX, tooltipY + tooltipHeight - radius);
                    ctx.lineTo(tooltipX, tooltipY + radius);
                    ctx.quadraticCurveTo(tooltipX, tooltipY, tooltipX + radius, tooltipY);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                    
                    // Draw tooltip content
                    ctx.fillStyle = '#333333';
                    ctx.font = 'bold 12px Arial';
                    ctx.textAlign = 'left';
                    ctx.fillText(lines[0], tooltipX + padding, tooltipY + padding + 12);
                    
                    // Draw separator line
                    ctx.strokeStyle = '#E0E0E0';
                    ctx.lineWidth = 1;
                    ctx.beginPath();
                    ctx.moveTo(tooltipX + padding, tooltipY + padding + 18);
                    ctx.lineTo(tooltipX + tooltipWidth - padding, tooltipY + padding + 18);
                    ctx.stroke();
                    
                    // Draw price data
                    ctx.font = '12px Arial';
                    for (let i = 1; i < lines.length - 1; i++) {
                        ctx.fillStyle = '#333333';
                        ctx.fillText(lines[i], tooltipX + padding, tooltipY + padding + lineHeight * (i + 1));
                    }
                    
                    // Draw change with color
                    ctx.fillStyle = changeColor;
                    ctx.font = 'bold 12px Arial';
                    ctx.fillText(lines[lines.length - 1], tooltipX + padding, tooltipY + padding + lineHeight * (lines.length));
                },
                
                // Draw price scale on the right - MANY LEVELS like TradingView reference
                drawPriceScale: function(chartArea, minPrice, maxPrice, priceRange, margin) {
                    const ctx = this.ctx;
                    
                    // Update HTML price scale with many levels (like TradingView reference)
                    this.updateHTMLPriceScale(minPrice, maxPrice, margin);
                    
                    // Also draw on canvas for consistency
                    const steps = 15; // Many more price levels like reference (15 levels)
                    const adjustedMinPrice = minPrice - margin;
                    const adjustedMaxPrice = maxPrice + margin;
                    const totalPriceRange = adjustedMaxPrice - adjustedMinPrice;
                    
                    ctx.fillStyle = '#666666'; // Gray color like reference
                    ctx.font = '10px Arial';
                    ctx.textAlign = 'right';
                    
                    // Draw price labels at each step
                    for (let i = 0; i <= steps; i++) {
                        const price = adjustedMaxPrice - (i * totalPriceRange / steps);
                        const y = chartArea.top + ((i * chartArea.height) / steps);
                        
                        // Format price like TradingView: 1,398.00 format
                        const formattedPrice = price.toFixed(2);
                        
                        // Price label positioned on canvas
                        ctx.fillText(formattedPrice, this.width - 20, y + 3);
                    }
                },
                
                // Update HTML price scale with many levels (EXACT like TradingView reference)
                updateHTMLPriceScale: function(minPrice, maxPrice, margin) {
                    const adjustedMinPrice = minPrice - margin;
                    const adjustedMaxPrice = maxPrice + margin;
                    const totalPriceRange = adjustedMaxPrice - adjustedMinPrice;
                    const steps = 15; // 15 price levels like reference
                    
                    // Update each price level element
                    for (let i = 1; i <= 15; i++) {
                        const priceElement = document.getElementById(`priceLevel_${i}`);
                        if (priceElement) {
                            // Calculate price for this level (from top to bottom)
                            const levelIndex = i - 1;
                            const price = adjustedMaxPrice - (levelIndex * totalPriceRange / (steps - 1));
                            
                            // Format like TradingView: 1,398.00 format
                            const formattedPrice = price.toFixed(2);
                            priceElement.textContent = formattedPrice;
                        }
                    }
                    
                    console.log(`ğŸ“Š Updated price scale: ${adjustedMaxPrice.toFixed(2)} to ${adjustedMinPrice.toFixed(2)}`);
                }
            };
            
            // Store chart globally so it can be accessed for updates
            window.koreanCanvasChart = koreanChart;
            
            console.log('âœ… Korean chart initialized successfully!');
            return koreanChart;
        }

        // Update Korean chart with new data
        function updateKoreanChart(candlestickData) {
            if (!window.koreanCanvasChart) {
                console.error('âŒ Korean chart not initialized');
                return;
            }
            
            console.log(`ğŸ›ï¸ Updating Korean chart with ${candlestickData.length} candles`);
            window.koreanCanvasChart.updateData(candlestickData);
        }

        // Prediction point management functions
        function createOrUpdatePrediction(date, price) {
            const existingIndex = predictions.findIndex(p => {
                const predDate = new Date(p.date);
                const diffDays = Math.abs((predDate - date) / (1000 * 60 * 60 * 24));
                return diffDays < 1;
            });

            if (existingIndex >= 0) {
                // Update existing prediction
                predictions[existingIndex].price = price;
                predictions[existingIndex].date = date.toISOString();
            } else {
                // Add new prediction
                predictions.push({
                    date: date.toISOString(),
                    price: price,
                    id: Date.now()
                });
            }

            // Redraw chart and update UI
            if (window.koreanCanvasChart) {
                window.koreanCanvasChart.draw();
            }
            updatePredictionsList();
            showMessage(`ì˜ˆì¸¡ ì„¤ì •: ${date.toLocaleDateString('ko-KR')} - $${price.toFixed(2)}`, 'info');
        }

        // Show prediction delete button
        function showPredictionDeleteButton(mouseX, mouseY, prediction) {
            let deleteBtn = document.getElementById('predictionDeleteBtn');
            
            if (!deleteBtn) {
                deleteBtn = document.createElement('div');
                deleteBtn.id = 'predictionDeleteBtn';
                deleteBtn.className = 'fixed bg-red-500 hover:bg-red-600 text-white rounded-full w-8 h-8 flex items-center justify-center cursor-pointer z-50 transition-all duration-200 shadow-lg';
                deleteBtn.innerHTML = '<i class="fas fa-times text-sm"></i>';
                deleteBtn.title = 'ì˜ˆì¸¡ ì‚­ì œ';
                document.body.appendChild(deleteBtn);
                
                // BOSS REQUIREMENT: Fix X delete icon movement bug
                // "ì°¨íŠ¸ì— ë§ˆìš°ìŠ¤ í´ë¦­í•˜ë©´ ì—‘ìŠ¤ë°•ìŠ¤ ì‚­ì œ ì•„ì´ì½˜ì´ ëœ¨ëŠ”ë° ê·¸ê±¸ í´ë¦­í•˜ë ¤ë©´ ì•„ì´ì½˜ì´ ì›€ì§ì—¬ì„œ ì‚­ì œ ì•ˆëœë‹¤"
                // Position the button only when first created - it will NEVER move after this
                const chartRect = window.koreanCanvasChart.canvas.getBoundingClientRect();
                deleteBtn.style.left = (chartRect.left + mouseX + 15) + 'px';
                deleteBtn.style.top = (chartRect.top + mouseY - 15) + 'px';
                deleteBtn._isPositioned = true; // Mark as positioned
                console.log('ğŸ¯ Boss requirement: Delete button positioned and LOCKED at:', deleteBtn.style.left, deleteBtn.style.top);
            }
            
            // Simply show the button - NEVER reposition it once created
            deleteBtn.style.display = 'flex';
            
            // Remove existing click handler and add new one
            deleteBtn.onclick = null;
            deleteBtn.onclick = function(e) {
                e.stopPropagation();
                removePrediction(prediction.id);
                hidePredictionDeleteButton();
                showMessage('ì˜ˆì¸¡ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.', 'info');
                console.log('âœ… Boss requirement: Prediction deleted successfully');
            };
        }

        // Hide prediction delete button
        function hidePredictionDeleteButton() {
            const deleteBtn = document.getElementById('predictionDeleteBtn');
            if (deleteBtn) {
                deleteBtn.style.display = 'none';
            }
        }

        // Korean stock names mapping
        const koreanStockNames = {
            'AAPL': 'ì• í”Œ',
            'MSFT': 'ë§ˆì´í¬ë¡œì†Œí”„íŠ¸', 
            'GOOGL': 'êµ¬ê¸€',
            'AMZN': 'ì•„ë§ˆì¡´',
            'TSLA': 'í…ŒìŠ¬ë¼',
            'NVDA': 'ì—”ë¹„ë””ì•„',
            'META': 'ë©”íƒ€',
            'NFLX': 'ë„·í”Œë¦­ìŠ¤',
            'BTC-USD': 'ë¹„íŠ¸ì½”ì¸',
            'ETH-USD': 'ì´ë”ë¦¬ì›€',
            '005930.KS': 'ì‚¼ì„±ì „ì',
            '000660.KS': 'SKí•˜ì´ë‹‰ìŠ¤',
            '035420.KS': 'ë„¤ì´ë²„'
        };

        // Function to get Korean name for stock
        function getKoreanStockName(symbol) {
            return koreanStockNames[symbol] || symbol;
        }

        // Convert price data to candlestick OHLC format for Korean chart
        function convertToCandlestickData(priceData) {
            if (!priceData || priceData.length === 0) {
                console.warn('âš ï¸ No price data provided to convertToCandlestickData');
                return [];
            }
            
            console.log(`ğŸ•¯ï¸ Converting ${priceData.length} data points to candlestick format`);
            console.log('Sample input data:', priceData[0]);
            
            // FORCE LIMIT TO 15 POINTS FOR MAXIMUM THICK KOREAN-STYLE CANDLESTICKS
            const limitedData = priceData.slice(-15);
            
            // Convert real API data to candlestick format - using enhanced OHLC data
            return limitedData.map((item, index) => {
                // Check if we have OHLC data from API processing
                if (item.open !== undefined && item.high !== undefined && 
                    item.low !== undefined && item.close !== undefined) {
                    
                    let x = item.x || item.timestamp;
                    if (x instanceof Date) {
                        x = x.getTime();
                    } else if (typeof x === 'string') {
                        x = new Date(x).getTime();
                    } else if (typeof x !== 'number') {
                        x = Date.now();
                    }
                    
                    console.log(`âœ… Converting OHLC data for index ${index}: O:${item.open}, H:${item.high}, L:${item.low}, C:${item.close}`);
                    return {
                        x: x,
                        o: Math.max(item.open, 0.01),
                        h: Math.max(item.high, 0.01), 
                        l: Math.max(item.low, 0.01),
                        c: Math.max(item.close, 0.01)
                    };
                }
                
                // Legacy support for old format with o,h,l,c properties
                if (item.o !== undefined && item.h !== undefined && item.l !== undefined && item.c !== undefined) {
                    let x = item.x || item.timestamp;
                    if (x instanceof Date) {
                        x = x.getTime();
                    } else if (typeof x === 'string') {
                        x = new Date(x).getTime();
                    }
                    
                    return {
                        x: x,
                        o: Math.max(item.o, 0.01),
                        h: Math.max(item.h, 0.01), 
                        l: Math.max(item.l, 0.01),
                        c: Math.max(item.c, 0.01)
                    };
                }
                
                console.warn('âš ï¸ Item missing OHLC data structure:', item);
                return null;
            }).filter(item => item !== null);
        }

        // Helper function to ensure consistent date parsing
        function parseDate(dateInput) {
            if (dateInput instanceof Date) {
                return isNaN(dateInput.getTime()) ? null : dateInput;
            }
            
            if (typeof dateInput === 'string' || typeof dateInput === 'number') {
                const parsed = new Date(dateInput);
                return isNaN(parsed.getTime()) ? null : parsed;
            }
            
            return null;
        }

        // Helper function to convert date to timestamp for Chart.js
        function dateToTimestamp(dateInput) {
            // If it's already a number, check if it's a valid timestamp
            if (typeof dateInput === 'number') {
                // If it's a valid timestamp (either seconds or milliseconds), use it
                if (dateInput > 0) {
                    // If it looks like seconds (less than year 2100), convert to milliseconds
                    if (dateInput < 4000000000) {
                        return dateInput * 1000;
                    }
                    return dateInput;
                }
            }
            
            // Try to parse as date
            const date = parseDate(dateInput);
            if (date) {
                return date.getTime();
            }
            
            // Fallback to current time
            return Date.now();
        }

        // Global variables
        let chart = null;
        let volumeChart = null;
        let stockData = [];
        let volumeData = [];
        let currentStockSymbol = '';
        let predictions = [];
        let isDragging = false;
        let currentInterval = '1d';
        let chartScrollPosition = 70; // Start at 70% to show some past and future
        let hoveredPredictionPoint = null;
        let totalChartDays = 90; // Total days to show
        let futureData = []; // Store future dates for navigation
        
        // BOSS REQUIREMENT: Global zoom variables for direct chart control
        let globalZoomLevel = 1.0;
        let globalScrollOffset = 0;

        // DOM elements
        const stockSelect = document.getElementById('stockSelect');
        const stockSearch = document.getElementById('stockSearch');
        const stockSearchInput = document.getElementById('stockSearchInput'); // Fixed: Use correct ID
        const chartScrollbar = document.getElementById('chartScrollbar');
        const timeIntervalBtns = document.querySelectorAll('.time-interval-btn');
        const showVolumeCheckbox = document.getElementById('showVolume');
        const volumeContainer = document.getElementById('volumeContainer');
        const resetZoomBtn = document.getElementById('resetZoom');
        const predictionTooltip = document.getElementById('predictionTooltip');
        const deletePredictionBtn = document.getElementById('deletePredictionBtn');
        const stockInfo = document.getElementById('stockInfo');
        const chartContainer = document.getElementById('chartContainer');
        // chartCanvas already declared at top - removed duplicate
        const chartLoading = document.getElementById('chartLoading');
        const noStockSelected = document.getElementById('noStockSelected');
        const chartTimeRange = document.getElementById('chartTimeRange');
        const clearPredictions = document.getElementById('clearPredictions');
        const fitChart = document.getElementById('fitChart');
        const predictionsPanel = document.getElementById('predictionsPanel');
        const predictionsList = document.getElementById('predictionsList');
        const predictionCount = document.getElementById('predictionCount');
        const currentPriceDisplay = document.getElementById('currentPriceDisplay');
        const submitButton = document.getElementById('submitPrediction');
        const submitButtonText = document.getElementById('submitButtonText');
        const predictionForm = document.getElementById('predictionForm');
        const successMessage = document.getElementById('successMessage');
        const selectedStockName = document.getElementById('selectedStockName');
        const selectedStockSymbol = document.getElementById('selectedStockSymbol');
        const currentStockPrice = document.getElementById('currentStockPrice');
        const loadingPrice = document.getElementById('loadingPrice');

        // Function to determine market type based on symbol
        function getMarketType(symbol) {
            if (symbol.includes('-USD') || ['BTC', 'ETH', 'BNB', 'ADA', 'SOL', 'XRP', 'DOT', 'DOGE', 'AVAX', 'SHIB', 'MATIC', 'LTC', 'UNI', 'LINK', 'ATOM'].includes(symbol.split('-')[0])) {
                return 'crypto';
            } else if (symbol.includes('.KS')) {
                return 'kr_stock';
            } else if (symbol.includes('.T')) {
                return 'jp_stock';
            } else if (symbol.includes('.NS') || symbol.includes('.BO')) {
                return 'in_stock';
            } else if (symbol.includes('.L')) {
                return 'uk_stock';
            } else if (symbol.includes('.TO')) {
                return 'ca_stock';
            } else if (symbol.includes('.PA')) {
                return 'fr_stock';
            } else if (symbol.includes('.DE')) {
                return 'de_stock';
            } else if (symbol.includes('.TW')) {
                return 'tw_stock';
            } else {
                return 'us_stock';
            }
        }

        // Convert simple price data to candlestick OHLC format (grouped by period)
        function convertToCandlestickDataGrouped(priceData, period = 1) {
            if (!priceData || priceData.length === 0) return [];
            
            const candlestickData = [];
            
            // Group data by time periods to create candlesticks
            for (let i = 0; i < priceData.length; i += period) {
                const periodData = priceData.slice(i, i + period);
                if (periodData.length === 0) continue;
                
                const open = periodData[0].y;
                const close = periodData[periodData.length - 1].y;
                const high = Math.max(...periodData.map(d => d.y));
                const low = Math.min(...periodData.map(d => d.y));
                const date = periodData[0].x;
                
                // Ensure x is a timestamp in milliseconds
                let x = date;
                if (x instanceof Date) {
                    x = x.getTime();
                } else if (typeof x === 'string') {
                    x = new Date(x).getTime();
                } else if (typeof x !== 'number') {
                    x = Date.now();
                }
                
                candlestickData.push({
                    x: x, // Timestamp in milliseconds
                    o: open,
                    h: high,
                    l: low,
                    c: close
                });
            }
            
            return candlestickData;
        }

        // Initialize Korean candlestick chart (Pure Canvas - No Chart.js)
        function initializeChart() {
            console.log('ğŸ›ï¸ Initializing Pure Korean Candlestick Chart...');
            
            // Destroy any existing chart
            if (chart) {
                try {
                    chart.destroy();
                    console.log('Destroyed existing Chart.js instance');
                } catch (e) {
                    console.warn('Error destroying chart:', e);
                }
                chart = null;
            }
            
            // Initialize the Korean chart
            if (initializeKoreanChart()) {
                console.log('âœ… Pure Korean Chart initialized successfully');
                
                // Connect time interval buttons to the Korean chart
                document.querySelectorAll('.time-interval-btn').forEach(btn => {
                    btn.addEventListener('click', function() {
                        const interval = this.dataset.interval;
                        if (window.koreanCanvasChart) {
                            window.koreanCanvasChart.setTimeInterval(interval);
                        }
                    });
                });
                
                // BOSS REQUIREMENT: Make Korean chart globally accessible for zoom
                window.koreanCanvasChart = koreanChart;
                console.log('ğŸ”§ Korean chart made globally accessible for zoom functionality');
                
                return true;
            } else {
                console.error('âŒ Failed to initialize Korean chart');
                return false;
            }
        }

        // Initialize volume chart with Korean styling
        function initializeVolumeChart() {
            const volumeCtx = document.getElementById('volumeChart').getContext('2d');

            // Destroy existing volume chart if it exists
            if (volumeChart) {
                volumeChart.destroy();
                volumeChart = null;
            }

            // Use real volume data from API - NO SAMPLE DATA
            const realVolumeData = volumeData && volumeData.length > 0 ? volumeData : [];
            
            // If no real volume data available, don't create volume chart
            if (realVolumeData.length === 0) {
                console.log('ğŸ“Š No volume data available from APIs - skipping volume chart');
                return;
            }

            volumeChart = new Chart(volumeCtx, {
                type: 'bar',
                data: {
                    datasets: [{
                        label: 'ê±°ë˜ëŸ‰',
                        data: realVolumeData,
                        backgroundColor: function (context) {
                            const index = context.dataIndex;
                            // Use candlestick data if available to determine color
                            if (window.koreanChartData && index < window.koreanChartData.length) {
                                const candleData = window.koreanChartData[index];
                                return candleData.c >= candleData.o ? '#1976D2' : '#F44336'; // Blue for up, Red for down
                            }
                            return '#1976D2'; // Default blue
                        },
                        borderWidth: 0,
                        barThickness: 'flex', // Make volume bars thicker like reference image
                        categoryPercentage: 0.95,
                        barPercentage: 0.95
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    layout: {
                        padding: {
                            left: 10,
                            right: 10,
                            top: 5,
                            bottom: 5
                        }
                    },
                    plugins: {
                        legend: { display: false },
                        tooltip: {
                            backgroundColor: 'rgba(255, 255, 255, 0.95)',
                            titleColor: '#333',
                            bodyColor: '#333',
                            borderColor: '#ddd',
                            borderWidth: 1,
                            callbacks: {
                                title: function (context) {
                                    if (context[0]) {
                                        return new Date(context[0].parsed.x).toLocaleDateString('ko-KR');
                                    }
                                },
                                label: function (context) {
                                    return `ê±°ë˜ëŸ‰: ${formatVolume(context.parsed.y)}`;
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            type: 'time',
                            adapters: {
                                date: {
                                    locale: 'en'
                                }
                            },
                            time: {
                                parser: false, // Don't parse strings, use raw timestamps
                                unit: 'day'
                            },
                            display: false
                        },
                        y: {
                            beginAtZero: true,
                            position: 'right',
                            grid: {
                                color: '#e0e0e0',
                                drawBorder: false,
                                lineWidth: 0.5
                            },
                            ticks: {
                                color: '#666',
                                maxTicksLimit: 3,
                                callback: function (value) {
                                    return formatVolume(value);
                                },
                                font: {
                                    size: 9
                                }
                            },
                            border: {
                                display: false
                            }
                        }
                    }
                }
            });
        }

        // Format volume numbers
        function formatVolume(value) {
            if (value >= 1000000000) {
                return (value / 1000000000).toFixed(1) + 'B';
            } else if (value >= 1000000) {
                return (value / 1000000).toFixed(1) + 'M';
            } else if (value >= 1000) {
                return (value / 1000).toFixed(1) + 'K';
            }
            return value.toString();
        }

        // Handle chart click for predictions
        function handleChartClick(event, elements) {
            if (!currentStockSymbol || !chart || !chart.scales) return;

            const canvasPosition = Chart.helpers.getRelativePosition(event, chart);
            const dataX = chart.scales.x.getValueForPixel(canvasPosition.x);
            const dataY = chart.scales.y.getValueForPixel(canvasPosition.y);

            const clickDate = new Date(dataX);
            const today = new Date();
            today.setHours(0, 0, 0, 0);

            // Only allow predictions for future dates
            if (clickDate <= today) {
                showMessage('ë¯¸ë˜ ë‚ ì§œì—ë§Œ ì˜ˆì¸¡ì„ ì„¤ì •í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.', 'warning');
                return;
            }

            // Check if there's already a prediction for this date (within 1 day tolerance)
            const existingPredictionIndex = predictions.findIndex(p => {
                const predDate = new Date(p.date);
                const diffDays = Math.abs((predDate - clickDate) / (1000 * 60 * 60 * 24));
                return diffDays < 1;
            });

            if (existingPredictionIndex >= 0) {
                // Update existing prediction
                predictions[existingPredictionIndex].price = dataY;
                predictions[existingPredictionIndex].date = clickDate.toISOString();
            } else {
                // Add new prediction
                predictions.push({
                    date: clickDate.toISOString(),
                    price: dataY,
                    id: Date.now()
                });
            }

            updateChart();
            updatePredictionsList();
            showMessage(`ì˜ˆì¸¡ ì„¤ì •: ${clickDate.toLocaleDateString('ko-KR')} - $${dataY.toFixed(2)}`, 'info');
        }

        // Handle chart hover for prediction tooltips
        function handleChartHover(event, activeElements) {
            if (!chart || !chartCanvas) return;
            
            const canvasPosition = Chart.helpers.getRelativePosition(event, chart);

            // Check if hovering over a prediction point
            if (activeElements.length > 0) {
                const element = activeElements[0];
                if (element.datasetIndex === 1) { // Prediction dataset
                    const prediction = predictions[element.index];
                    if (prediction) {
                        showPredictionTooltip(event, prediction);
                        hoveredPredictionPoint = prediction;
                        chartCanvas.style.cursor = 'pointer';
                        return;
                    }
                }
            }

            // Hide tooltip if not hovering over prediction
            hidePredictionTooltip();
            hoveredPredictionPoint = null;
            chartCanvas.style.cursor = 'crosshair';
        }

        // Show prediction tooltip
        function showPredictionTooltip(event, prediction) {
            if (!predictionTooltip) return;
            
            const rect = chartCanvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            const tooltipDate = document.getElementById('tooltipDate');
            const tooltipPrice = document.getElementById('tooltipPrice');
            
            if (tooltipDate) {
                tooltipDate.textContent = new Date(prediction.date).toLocaleDateString('ko-KR');
            }
            if (tooltipPrice) {
                tooltipPrice.textContent = '$' + prediction.price.toFixed(2);
            }

            predictionTooltip.style.left = (x + 10) + 'px';
            predictionTooltip.style.top = (y - 10) + 'px';
            predictionTooltip.classList.remove('hidden');
        }

        // Hide prediction tooltip
        function hidePredictionTooltip() {
            if (predictionTooltip) {
                predictionTooltip.classList.add('hidden');
            }
        }

        // BOSS FIX: Enhanced Chart Update Function
        function updateChart() {
            console.log('ğŸ”„ BOSS FIX: Forcing chart update...');
            
            // Validate required data
            if (!stockData || stockData.length === 0) {
                console.warn('âš ï¸ BOSS FIX: No stock data available for chart update');
                return;
            }
            
            // Force update Korean chart
            if (window.koreanCanvasChart) {
                console.log('ğŸ“Š BOSS FIX: Updating Korean canvas chart');
                const candlestickData = convertToCandlestickData(stockData);
                window.koreanCanvasChart.updateData(candlestickData);
                window.koreanCanvasChart.draw(); // Force redraw
            } else {
                console.warn('âš ï¸ BOSS FIX: Korean chart not initialized, creating new one');
                initializeKoreanChart();
            }
            
            // Update volume chart if it exists
            if (volumeChart && volumeData.length > 0) {
                console.log('ğŸ“Š BOSS FIX: Updating volume chart');
                volumeChart.data.datasets[0].data = volumeData;
                volumeChart.update('none'); // Update without animation
            }
            
            // Update price info display
            if (stockData.length > 0) {
                updateStockInfoDisplay(currentStockSymbol, stockData);
                console.log('âœ… BOSS FIX: Stock info display updated');
            }
            
            // Force update chart time view
            updateChartView();
            
            // Update predictions list
            updatePredictionsList();
            
            console.log('âœ… BOSS FIX: Chart update completed successfully');
        }

        // Update predictions list display
        function updatePredictionsList() {
            if (predictions.length === 0) {
                predictionsPanel.classList.add('hidden');
                return;
            }

            predictionsPanel.classList.remove('hidden');
            if (predictionCount) {
                predictionCount.textContent = `${predictions.length}ê°œ ì˜ˆì¸¡`;
            }

            predictionsList.innerHTML = predictions
                .sort((a, b) => new Date(a.date) - new Date(b.date))
                .map(p => {
                    const date = new Date(p.date);
                    const currentPrice = getCurrentPrice();
                    const change = currentPrice ? ((p.price - currentPrice) / currentPrice * 100) : 0;
                    const changeClass = change >= 0 ? 'text-tv-green' : 'text-tv-red';
                    const changeIcon = change >= 0 ? 'ğŸ“ˆ' : 'ğŸ“‰';

                    return `
                        <div class="flex items-center justify-between p-3 bg-tv-card rounded-lg border border-tv-border">
                            <div class="flex-1">
                                <div class="flex items-center space-x-2">
                                    <span class="text-sm font-medium text-tv-text">${date.toLocaleDateString('ko-KR')}</span>
                                    <span class="text-xs text-tv-text-secondary">${date.toLocaleDateString('ko-KR', { weekday: 'short' })}</span>
                                </div>
                                <div class="flex items-center space-x-2 mt-1">
                                    <span class="text-lg font-bold text-tv-text">$${p.price.toFixed(2)}</span>
                                    <span class="${changeClass} text-sm font-medium">
                                        ${changeIcon} ${change >= 0 ? '+' : ''}${change.toFixed(2)}%
                                    </span>
                                </div>
                            </div>
                            <button onclick="removePrediction(${p.id})" class="ml-3 text-tv-red hover:text-red-400 transition-colors">
                                <i class="fas fa-times"></i>
                            </button>
                        </div>
                    `;
                }).join('');
        }

        // Remove prediction
        function removePrediction(id) {
            predictions = predictions.filter(p => p.id !== id);
            updateChart();
            updatePredictionsList();
        }

        // Clear all predictions
        if (clearPredictions) {
            clearPredictions.addEventListener('click', () => {
                predictions = [];
                updateChart();
                updatePredictionsList();
                showMessage('ëª¨ë“  ì˜ˆì¸¡ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.', 'info');
            });
        }

        // Fit chart to show all data
        if (fitChart) {
            fitChart.addEventListener('click', () => {
                if (chart && stockData.length > 0) {
                const minPrice = Math.min(...stockData.map(d => d.y));
                const maxPrice = Math.max(...stockData.map(d => d.y));
                const padding = (maxPrice - minPrice) * 0.1;

                chart.options.scales.y.min = minPrice - padding;
                chart.options.scales.y.max = maxPrice + padding;
                chart.update();
            }
        });
        }

        // BOSS FIX: Configuration Maker and Output Reader Functions
        
        // Enhanced configuration maker
        function saveChartConfiguration() {
            const config = {
                stockSymbol: currentStockSymbol,
                timeInterval: currentInterval,
                chartType: 'candlestick',
                showVolume: showVolumeCheckbox ? showVolumeCheckbox.checked : false,
                timeRange: chartTimeRange ? chartTimeRange.value : '90',
                predictions: predictions,
                timestamp: Date.now()
            };
            
            // Save to localStorage
            localStorage.setItem('chartConfig_' + currentStockSymbol, JSON.stringify(config));
            localStorage.setItem('lastChartConfig', JSON.stringify(config));
            
            console.log('âœ… BOSS FIX: Chart configuration saved:', config);
            showMessage('ì°¨íŠ¸ ì„¤ì •ì´ ì €ì¥ë˜ì—ˆìŠµë‹ˆë‹¤', 'success');
            
            return config;
        }
        
        // Enhanced output reader
        function loadChartConfiguration(symbol) {
            let config = null;
            
            try {
                // Try to load specific symbol configuration
                if (symbol) {
                    const savedConfig = localStorage.getItem('chartConfig_' + symbol);
                    if (savedConfig) {
                        config = JSON.parse(savedConfig);
                        console.log('ğŸ“– BOSS FIX: Loaded configuration for', symbol, ':', config);
                    }
                }
                
                // Fallback to last configuration
                if (!config) {
                    const lastConfig = localStorage.getItem('lastChartConfig');
                    if (lastConfig) {
                        config = JSON.parse(lastConfig);
                        console.log('ğŸ“– BOSS FIX: Loaded last configuration:', config);
                    }
                }
                
                // Apply configuration if found
                if (config) {
                    applyChartConfiguration(config);
                    showMessage('ì €ì¥ëœ ì„¤ì •ì„ ë¶ˆëŸ¬ì™”ìŠµë‹ˆë‹¤', 'info');
                    return config;
                }
            } catch (error) {
                console.error('âŒ BOSS FIX: Configuration loading failed:', error);
                showMessage('ì„¤ì •ì„ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤', 'error');
            }
            
            return null;
        }
        
        // Apply loaded configuration
        function applyChartConfiguration(config) {
            console.log('ğŸ”§ BOSS FIX: Applying configuration:', config);
            
            // Apply stock symbol
            if (config.stockSymbol && stockSelect) {
                stockSelect.value = config.stockSymbol;
                currentStockSymbol = config.stockSymbol;
            }
            
            // Apply time interval
            if (config.timeInterval) {
                currentInterval = config.timeInterval;
                // Update interval buttons
                document.querySelectorAll('.time-interval-btn').forEach(btn => {
                    btn.classList.toggle('active', btn.dataset.interval === config.timeInterval);
                });
            }
            
            // Apply time range
            if (config.timeRange && chartTimeRange) {
                chartTimeRange.value = config.timeRange;
            }
            
            // Apply volume display
            if (config.showVolume !== undefined && showVolumeCheckbox) {
                showVolumeCheckbox.checked = config.showVolume;
            }
            
            // Apply predictions
            if (config.predictions && Array.isArray(config.predictions)) {
                predictions = config.predictions;
                updatePredictionsList();
            }
            
            console.log('âœ… BOSS FIX: Configuration applied successfully');
        }
        
        // Auto-save configuration on changes
        function setupAutoSave() {
            // Save when stock changes
            if (stockSelect) {
                stockSelect.addEventListener('change', () => {
                    setTimeout(saveChartConfiguration, 500);
                });
            }
            
            // Save when time interval changes
            document.querySelectorAll('.time-interval-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    setTimeout(saveChartConfiguration, 500);
                });
            });
            
            // Save when volume setting changes
            if (showVolumeCheckbox) {
                showVolumeCheckbox.addEventListener('change', () => {
                    setTimeout(saveChartConfiguration, 500);
                });
            }
            
            console.log('âœ… BOSS FIX: Auto-save configuration setup completed');
        }
        
        // Enhanced output read function with retry mechanism
        async function readChartOutput(retryCount = 3) {
            console.log('ğŸ“Š BOSS FIX: Reading chart output...');
            
            const output = {
                stockData: stockData,
                volumeData: volumeData,
                predictions: predictions,
                currentSymbol: currentStockSymbol,
                configuration: loadChartConfiguration(currentStockSymbol),
                chartState: {
                    isLoaded: !!window.koreanCanvasChart,
                    dataPoints: stockData.length,
                    hasVolume: volumeData.length > 0,
                    hasPredictions: predictions.length > 0
                },
                timestamp: Date.now()
            };
            
            // Validate output
            if (!output.stockData || output.stockData.length === 0) {
                if (retryCount > 0) {
                    console.warn(`âš ï¸ BOSS FIX: Chart output incomplete, retrying... (${retryCount} attempts left)`);
                    await new Promise(resolve => setTimeout(resolve, 1000));
                    return readChartOutput(retryCount - 1);
                } else {
                    console.error('âŒ BOSS FIX: Chart output failed after all retries');
                    showMessage('ì°¨íŠ¸ ì¶œë ¥ì„ ì½ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤', 'error');
                    return null;
                }
            }
            
            console.log('âœ… BOSS FIX: Chart output read successfully:', output);
            return output;
        }

        // Get current price - restored function
        function getCurrentPrice() {
            if (stockData.length === 0) return 0;
            return stockData[stockData.length - 1].y || stockData[stockData.length - 1].c || 0;
        }

        // BOSS FIX: TradingView-style Mouse Wheel Implementation
        function initializeTradingViewWheel() {
            console.log('ğŸ”„ Initializing TradingView-style mouse wheel...');
            
            const chartCanvas = document.getElementById('priceChart');
            const chartContainer = chartCanvas ? chartCanvas.parentElement : null;
            
            if (!chartContainer) {
                console.error('âŒ Chart container not found for TradingView wheel');
                return;
            }
            
            console.log('âœ… Found chart container:', chartContainer);
            
            // Remove any existing wheel listeners to prevent duplicates
            const existingHandler = chartContainer._wheelHandler;
            if (existingHandler) {
                chartContainer.removeEventListener('wheel', existingHandler);
            }
            
            let isZooming = false;
            let zoomLevel = 1.0;
            let scrollPosition = 0;
            const zoomSensitivity = 0.15;
            const scrollSensitivity = 50;
            
            // Add TradingView-style cursor and styling
            chartContainer.style.cursor = 'crosshair';
            chartContainer.style.userSelect = 'none';
            chartContainer.style.position = 'relative';
            
            // Main wheel event handler with better detection
            function wheelHandler(e) {
                e.preventDefault();
                e.stopPropagation();
                
                const isCtrlPressed = e.ctrlKey || e.metaKey;
                
                if (isCtrlPressed) {
                    // INSTANT ZOOM - DIRECT EXECUTION
                    const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                    globalZoomLevel = Math.max(0.1, Math.min(5.0, globalZoomLevel * zoomFactor));
                    zoomLevel = globalZoomLevel;
                    
                    // Update display instantly
                    document.getElementById('zoomDisplay').textContent = `Zoom: ${Math.round(globalZoomLevel * 100)}%`;
                    
                    // Instant redraw
                    if (window.koreanCanvasChart && window.koreanCanvasChart.draw) {
                        window.koreanCanvasChart.draw();
                    }
                } else {
                    // INSTANT SCROLL
                    globalScrollOffset = Math.max(0, globalScrollOffset + (e.deltaY > 0 ? 1 : -1));
                    
                    if (window.koreanCanvasChart && window.koreanCanvasChart.draw) {
                        window.koreanCanvasChart.draw();
                    }
                }
            }
            
            // Attach the wheel handler
            chartContainer.addEventListener('wheel', wheelHandler, { passive: false });
            chartContainer._wheelHandler = wheelHandler; // Store reference for cleanup
            
            // Also attach to the canvas directly for better coverage
            if (chartCanvas) {
                chartCanvas.addEventListener('wheel', wheelHandler, { passive: false });
                console.log('âœ… Wheel handler attached to canvas');
            }
            
            // Zoom function
            function handleTradingViewZoom(delta, mouseX, mouseY) {
                const zoomFactor = delta > 0 ? (1 - zoomSensitivity) : (1 + zoomSensitivity);
                const newZoom = Math.max(0.1, Math.min(5.0, zoomLevel * zoomFactor));
                
                if (newZoom === zoomLevel) return;
                
                zoomLevel = newZoom;
                
                // BOSS REQUIREMENT: Sync with global zoom level immediately
                globalZoomLevel = zoomLevel;
                
                // Apply zoom to Korean chart
                applyTradingViewZoom(newZoom);
                
                // Show zoom indicator
                showTradingViewZoomIndicator(newZoom);
            }
            
            // Scroll function
            function handleTradingViewScroll(delta) {
                const scrollAmount = delta > 0 ? scrollSensitivity : -scrollSensitivity;
                scrollPosition = Math.max(0, scrollPosition + scrollAmount);
                
                console.log(`ğŸ“œ TradingView Scroll: ${scrollPosition}`);
                
                // Apply scroll to Korean chart
                applyTradingViewScroll(scrollPosition);
                
                // Show scroll feedback
                showScrollFeedback(scrollPosition);
            }
            
            // Apply zoom to the Korean chart
            function applyTradingViewZoom(zoom) {
                // Update global zoom level directly - NO LOGGING TO AVOID DELAY
                globalZoomLevel = zoom;
                
                // Update zoom display
                document.getElementById('zoomDisplay').textContent = `Zoom: ${Math.round(zoom * 100)}%`;
                
                // BOSS REQUIREMENT: INSTANT chart redraw - NO DELAYS
                if (window.koreanCanvasChart && typeof window.koreanCanvasChart.draw === 'function') {
                    // Skip canvas clearing for speed - draw function handles it
                    window.koreanCanvasChart.draw();
                }
            }
            
            // Apply scroll to the Korean chart
            function applyTradingViewScroll(scroll) {
                // Update global scroll offset directly - NO LOGGING
                globalScrollOffset = Math.max(0, Math.floor(scroll / 20));
                
                // Update scroll display
                document.getElementById('scrollDisplay').textContent = `Scroll: ${scroll}`;
                
                // BOSS REQUIREMENT: INSTANT chart redraw
                if (window.koreanCanvasChart && typeof window.koreanCanvasChart.draw === 'function') {
                    window.koreanCanvasChart.draw();
                }
            }
            
            // Show zoom indicator like TradingView
            function showTradingViewZoomIndicator(zoom) {
                // Use existing zoom display for instant response - no DOM creation
                const zoomDisplay = document.getElementById('zoomDisplay');
                if (zoomDisplay) {
                    zoomDisplay.textContent = `Zoom: ${Math.round(zoom * 100)}%`;
                }
            }
            
            // Show scroll feedback
            function showScrollFeedback(scroll) {
                // Remove existing feedback
                const existing = document.querySelector('.tv-scroll-indicator');
                if (existing) existing.remove();
                
                // Create new feedback
                const indicator = document.createElement('div');
                indicator.className = 'tv-scroll-indicator';
                indicator.style.cssText = `
                    position: fixed;
                    top: 60px;
                    right: 20px;
                    background: rgba(0, 100, 200, 0.9);
                    color: white;
                    padding: 6px 12px;
                    border-radius: 15px;
                    font-size: 11px;
                    font-weight: 600;
                    z-index: 10000;
                    pointer-events: none;
                `;
                indicator.textContent = `Scroll: ${scroll.toFixed(0)}px`;
                
                document.body.appendChild(indicator);
                
                // Auto-remove quickly
                setTimeout(() => {
                    if (indicator.parentElement) {
                        indicator.remove();
                    }
                }, 1000);
            }
            
            // Keyboard shortcuts like TradingView
            function keyboardHandler(e) {
                if (!chartContainer.matches(':hover')) return;
                
                if (e.ctrlKey || e.metaKey) {
                    switch(e.code) {
                        case 'Equal':
                        case 'NumpadAdd':
                            e.preventDefault();
                            handleTradingViewZoom(-100, 0, 0);
                            break;
                        case 'Minus':
                        case 'NumpadSubtract':
                            e.preventDefault();
                            handleTradingViewZoom(100, 0, 0);
                            break;
                        case 'Digit0':
                        case 'Numpad0':
                            e.preventDefault();
                            zoomLevel = 1.0;
                            
                            // BOSS REQUIREMENT: Sync with global zoom level
                            globalZoomLevel = zoomLevel;
                            scrollPosition = stockData.length * 5; // Show recent data
                            applyTradingViewZoom(1.0);
                            applyTradingViewScroll(scrollPosition);
                            showTradingViewZoomIndicator(1.0);
                            break;
                    }
                }
            }
            
            document.addEventListener('keydown', keyboardHandler);
            
            // Add control buttons
            addTradingViewControlButtons();
            
            console.log('âœ… TradingView-style mouse wheel initialized successfully');
            
            // Test the setup
            console.log('ğŸ“Š Chart setup test:', {
                chartContainer: !!chartContainer,
                chartCanvas: !!chartCanvas,
                koreanChart: !!window.koreanCanvasChart,
                stockDataLength: stockData ? stockData.length : 0
            });
        }
        
        // Add TradingView control buttons
        function addTradingViewControlButtons() {
            const controlsContainer = document.querySelector('.chart-controls, .prediction-controls, .time-controls');
            if (!controlsContainer) return;
            
            const wheelControls = document.createElement('div');
            wheelControls.className = 'wheel-controls';
            wheelControls.style.cssText = 'margin: 10px 0; display: flex; gap: 5px; align-items: center; background: #f0f8ff; padding: 10px; border-radius: 8px; border: 2px solid #007bff;';
            
            // Add debug info
            const debugInfo = document.createElement('div');
            debugInfo.id = 'wheel-debug-info';
            debugInfo.style.cssText = 'margin-right: 15px; font-size: 11px; color: #333; font-family: monospace;';
            debugInfo.innerHTML = `
                <div>ë§ˆìš°ìŠ¤ íœ  ìƒíƒœ: <span id="wheel-status">ëŒ€ê¸°ì¤‘</span></div>
                <div>ë§ˆì§€ë§‰ ë™ì‘: <span id="last-action">ì—†ìŒ</span></div>
            `;
            wheelControls.appendChild(debugInfo);
            
            // Test button
            const testBtn = createControlButton('ï¿½', 'Test Wheel', () => {
                document.getElementById('wheel-status').textContent = 'í…ŒìŠ¤íŠ¸ì¤‘...';
                document.getElementById('last-action').textContent = 'Manual Test';
                console.log('ğŸ”§ Manual wheel test triggered');
                
                // Simulate a zoom event
                const fakeEvent = {
                    deltaY: -100,
                    clientX: 400,
                    clientY: 300,
                    ctrlKey: true,
                    preventDefault: () => {},
                    stopPropagation: () => {}
                };
                
                // Try to trigger wheel handler directly
                const chartContainer = document.querySelector('.chart-container');
                if (chartContainer && chartContainer._wheelHandler) {
                    chartContainer._wheelHandler(fakeEvent);
                    document.getElementById('wheel-status').textContent = 'í…ŒìŠ¤íŠ¸ ì™„ë£Œ';
                } else {
                    document.getElementById('wheel-status').textContent = 'í•¸ë“¤ëŸ¬ ì—†ìŒ';
                }
            });
            
            // Zoom controls
            const zoomInBtn = createControlButton('ğŸ”+', 'Zoom In', () => {
                document.getElementById('last-action').textContent = 'Zoom In Button';
                const event = { deltaY: -100, clientX: 0, clientY: 0, ctrlKey: true, preventDefault: () => {}, stopPropagation: () => {} };
                const chartContainer = document.querySelector('.chart-container');
                if (chartContainer && chartContainer._wheelHandler) {
                    chartContainer._wheelHandler(event);
                }
            });
            
            const zoomOutBtn = createControlButton('ğŸ”-', 'Zoom Out', () => {
                document.getElementById('last-action').textContent = 'Zoom Out Button';
                const event = { deltaY: 100, clientX: 0, clientY: 0, ctrlKey: true, preventDefault: () => {}, stopPropagation: () => {} };
                const chartContainer = document.querySelector('.chart-container');
                if (chartContainer && chartContainer._wheelHandler) {
                    chartContainer._wheelHandler(event);
                }
            });
            
            const scrollLeftBtn = createControlButton('â¬…ï¸', 'Scroll Left', () => {
                document.getElementById('last-action').textContent = 'Scroll Left';
                const event = { deltaY: -100, clientX: 0, clientY: 0, ctrlKey: false, preventDefault: () => {}, stopPropagation: () => {} };
                const chartContainer = document.querySelector('.chart-container');
                if (chartContainer && chartContainer._wheelHandler) {
                    chartContainer._wheelHandler(event);
                }
            });
            
            const scrollRightBtn = createControlButton('â¡ï¸', 'Scroll Right', () => {
                document.getElementById('last-action').textContent = 'Scroll Right';
                const event = { deltaY: 100, clientX: 0, clientY: 0, ctrlKey: false, preventDefault: () => {}, stopPropagation: () => {} };
                const chartContainer = document.querySelector('.chart-container');
                if (chartContainer && chartContainer._wheelHandler) {
                    chartContainer._wheelHandler(event);
                }
            });
            
            const resetBtn = createControlButton('ğŸ”„', 'Reset Zoom', () => {
                document.getElementById('last-action').textContent = 'Reset';
                const keyEvent = { ctrlKey: true, code: 'Digit0', preventDefault: () => {} };
                document.dispatchEvent(new KeyboardEvent('keydown', keyEvent));
            });
            
            wheelControls.appendChild(testBtn);
            wheelControls.appendChild(zoomInBtn);
            wheelControls.appendChild(zoomOutBtn);
            wheelControls.appendChild(scrollLeftBtn);
            wheelControls.appendChild(scrollRightBtn);
            wheelControls.appendChild(resetBtn);
            
            const label = document.createElement('div');
            label.innerHTML = '<strong>ğŸ–±ï¸ TradingView íœ  ì»¨íŠ¸ë¡¤</strong>';
            label.style.cssText = 'width: 100%; margin-bottom: 5px; color: #007bff; font-size: 14px;';
            wheelControls.insertBefore(label, wheelControls.firstChild);
            
            controlsContainer.appendChild(wheelControls);
            
            console.log('âœ… TradingView control buttons with debug info added');
        }
        
        function createControlButton(text, title, onClick) {
            const btn = document.createElement('button');
            btn.textContent = text;
            btn.title = title;
            btn.className = 'btn btn-sm';
            btn.style.cssText = `
                min-width: 32px;
                height: 32px;
                padding: 4px;
                margin: 0 2px;
                background: #f8f9fa;
                border: 1px solid #dee2e6;
                border-radius: 4px;
                font-size: 14px;
                cursor: pointer;
                transition: all 0.2s ease;
            `;
            btn.addEventListener('click', onClick);
            btn.addEventListener('mouseenter', () => {
                btn.style.background = '#e9ecef';
                btn.style.transform = 'scale(1.05)';
            });
            btn.addEventListener('mouseleave', () => {
                btn.style.background = '#f8f9fa';
                btn.style.transform = 'scale(1)';
            });
            return btn;
        }

        // BOSS FIX: Enhanced Chart Click Handler with Persistent X-Axis Icons
        
        let xAxisIcons = []; // Store all X-axis icons
        let chartClickEnabled = true;
        
        // Main chart click handler
        function setupChartClickHandler() {
            const chartContainers = [
                '#priceChart',
                '.chart-container',
                '#koreanChartContainer'
            ];
            
            chartContainers.forEach(selector => {
                const container = document.querySelector(selector);
                if (container) {
                    container.addEventListener('click', handleChartClick);
                    container.style.position = 'relative'; // Ensure proper positioning
                    console.log('âœ… BOSS FIX: Chart click handler setup for', selector);
                }
            });
        }
        
        function handleChartClick(event) {
            if (!chartClickEnabled) return;
            
            console.log('ğŸ–±ï¸ BOSS FIX: Chart clicked at:', event.offsetX, event.offsetY);
            
            // Get click position relative to chart
            const rect = event.target.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;
            
            // Create persistent X-axis icon
            createPersistentXAxisIcon(event.currentTarget, x, y);
            
            // Prevent event bubbling
            event.stopPropagation();
        }
        
        function createPersistentXAxisIcon(container, x, y) {
            console.log('ğŸ“ BOSS FIX: Creating persistent X-axis icon at', x, y);
            
            // Create icon element
            const icon = document.createElement('div');
            icon.className = 'x-axis-stock-icon';
            icon.setAttribute('data-icon-id', Date.now());
            
            // Icon styling - make it very visible and persistent
            icon.style.cssText = `
                position: absolute !important;
                left: ${x - 12}px !important;
                top: ${y - 12}px !important;
                width: 24px !important;
                height: 24px !important;
                background: linear-gradient(135deg, #2962ff, #1976d2) !important;
                border: 2px solid white !important;
                border-radius: 50% !important;
                cursor: pointer !important;
                z-index: 9999 !important;
                display: flex !important;
                align-items: center !important;
                justify-content: center !important;
                color: white !important;
                font-size: 10px !important;
                font-weight: bold !important;
                box-shadow: 0 3px 12px rgba(41, 98, 255, 0.4) !important;
                transition: all 0.2s ease !important;
                user-select: none !important;
                pointer-events: all !important;
            `;
            
            // Icon content
            icon.innerHTML = 'ğŸ“Š';
            
            // BOSS REQUIREMENT: Icon must persist when clicked
            icon.addEventListener('click', function(e) {
                e.stopPropagation();
                e.preventDefault();
                
                console.log('ğŸ”’ BOSS FIX: X-axis icon clicked - STAYING VISIBLE');
                
                // Add click effect without removing
                icon.style.transform = 'scale(1.2)';
                icon.style.boxShadow = '0 4px 16px rgba(41, 98, 255, 0.6)';
                
                setTimeout(() => {
                    icon.style.transform = 'scale(1)';
                    icon.style.boxShadow = '0 3px 12px rgba(41, 98, 255, 0.4)';
                }, 150);
                
                // Show stock info tooltip
                showStockIconTooltip(icon, x, y);
                
                return false; // Prevent any default behavior
            });
            
            // Hover effects
            icon.addEventListener('mouseenter', function() {
                this.style.transform = 'scale(1.1)';
                this.style.boxShadow = '0 4px 16px rgba(41, 98, 255, 0.6)';
            });
            
            icon.addEventListener('mouseleave', function() {
                this.style.transform = 'scale(1)';
                this.style.boxShadow = '0 3px 12px rgba(41, 98, 255, 0.4)';
            });
            
            // Add to container and store reference
            container.appendChild(icon);
            xAxisIcons.push(icon);
            
            console.log('âœ… BOSS FIX: X-axis icon created and made persistent');
            
            // Show confirmation message
            showMessage(`Xì¶• ì•„ì´ì½˜ì´ ìƒì„±ë˜ì—ˆìŠµë‹ˆë‹¤ (${xAxisIcons.length}ê°œ)`, 'success');
            
            return icon;
        }
        
        function showStockIconTooltip(icon, x, y) {
            // Remove existing tooltip
            const existingTooltip = document.querySelector('.stock-icon-tooltip');
            if (existingTooltip) {
                existingTooltip.remove();
            }
            
            // Create tooltip
            const tooltip = document.createElement('div');
            tooltip.className = 'stock-icon-tooltip';
            tooltip.style.cssText = `
                position: absolute !important;
                left: ${x + 30}px !important;
                top: ${y - 30}px !important;
                background: rgba(0, 0, 0, 0.9) !important;
                color: white !important;
                padding: 8px 12px !important;
                border-radius: 6px !important;
                font-size: 12px !important;
                z-index: 10000 !important;
                pointer-events: none !important;
                white-space: nowrap !important;
            `;
            
            const currentPrice = getCurrentPrice();
            tooltip.innerHTML = `
                <div>ì¢…ëª©: ${currentStockSymbol || 'N/A'}</div>
                <div>í˜„ì¬ê°€: $${currentPrice.toFixed(2)}</div>
                <div>ì‹œê°„: ${new Date().toLocaleTimeString()}</div>
            `;
            
            icon.parentElement.appendChild(tooltip);
            
            // Auto-remove tooltip after 3 seconds
            setTimeout(() => {
                if (tooltip.parentElement) {
                    tooltip.parentElement.removeChild(tooltip);
                }
            }, 3000);
        }
        
        // Clear all X-axis icons
        function clearAllXAxisIcons() {
            console.log('ğŸ§¹ BOSS FIX: Clearing all X-axis icons');
            
            xAxisIcons.forEach(icon => {
                if (icon.parentElement) {
                    icon.parentElement.removeChild(icon);
                }
            });
            
            xAxisIcons = [];
            showMessage('ëª¨ë“  Xì¶• ì•„ì´ì½˜ì´ ì œê±°ë˜ì—ˆìŠµë‹ˆë‹¤', 'info');
        }
        
        // Toggle chart click functionality
        function toggleChartClick(enabled = !chartClickEnabled) {
            chartClickEnabled = enabled;
            console.log('ğŸ”§ BOSS FIX: Chart click', enabled ? 'enabled' : 'disabled');
            showMessage(`ì°¨íŠ¸ í´ë¦­ ê¸°ëŠ¥ì´ ${enabled ? 'í™œì„±í™”' : 'ë¹„í™œì„±í™”'}ë˜ì—ˆìŠµë‹ˆë‹¤`, 'info');
        }
        
        // Add control buttons for icon management
        function addIconControlButtons() {
            const controlsContainer = document.querySelector('.chart-controls, .prediction-controls');
            if (!controlsContainer) return;
            
            const buttonContainer = document.createElement('div');
            buttonContainer.className = 'icon-controls';
            buttonContainer.style.cssText = 'margin: 10px 0; display: flex; gap: 10px; flex-wrap: wrap;';
            
            // Clear icons button
            const clearButton = document.createElement('button');
            clearButton.textContent = 'ì•„ì´ì½˜ ëª¨ë‘ ì œê±°';
            clearButton.className = 'btn btn-sm';
            clearButton.onclick = clearAllXAxisIcons;
            
            // Toggle click button
            const toggleButton = document.createElement('button');
            toggleButton.textContent = 'í´ë¦­ ê¸°ëŠ¥ í† ê¸€';
            toggleButton.className = 'btn btn-sm';
            toggleButton.onclick = () => toggleChartClick();
            
            buttonContainer.appendChild(clearButton);
            buttonContainer.appendChild(toggleButton);
            controlsContainer.appendChild(buttonContainer);
            
            console.log('âœ… BOSS FIX: Icon control buttons added');
        }

        // Update Korean chart UI with real stock data
        function updateStockInfoDisplay(symbol, stockData) {
            if (!stockData || stockData.length === 0) return;
            
            const currentPrice = stockData[stockData.length - 1].y;
            const previousPrice = stockData.length > 1 ? stockData[stockData.length - 2].y : currentPrice;
            const priceChange = currentPrice - previousPrice;
            const priceChangePercent = ((priceChange / previousPrice) * 100);
            
            // Calculate high and low from data
            const prices = stockData.map(d => d.y);
            const dayHigh = Math.max(...prices);
            const dayLow = Math.min(...prices);
            
            // Calculate volume if available
            const totalVolume = volumeData.reduce((sum, d) => sum + (d.volume || d.y || 0), 0);
            
            // Update header
            const headerStockName = document.getElementById('headerStockName');
            if (headerStockName) {
                headerStockName.textContent = getStockDisplayName(symbol);
            }
            
            // Update info bar
            const stockCode = document.getElementById('stockCode');
            const stockNameKorean = document.getElementById('stockNameKorean');
            const currentPriceEl = document.getElementById('currentPrice');
            const priceChangeEl = document.getElementById('priceChange');
            const priceChangePercentEl = document.getElementById('priceChangePercent');
            const dayHighEl = document.getElementById('dayHigh');
            const dayLowEl = document.getElementById('dayLow');
            const volumeEl = document.getElementById('volume');
            const marketCapEl = document.getElementById('marketCap');
            
            if (stockCode) stockCode.textContent = symbol;
            if (stockNameKorean) stockNameKorean.textContent = getKoreanStockName(symbol);
            
            // Set color based on price movement (Korean style: blue up, red down)
            const isUp = priceChange >= 0;
            const colorClass = isUp ? 'text-blue-600' : 'text-red-600';
            const arrow = isUp ? 'â–²' : 'â–¼';
            
            if (currentPriceEl) {
                currentPriceEl.textContent = `$${currentPrice.toFixed(2)}`;
                currentPriceEl.className = `text-lg font-bold ${colorClass}`;
            }
            
            if (priceChangeEl) {
                priceChangeEl.textContent = `${arrow} ${Math.abs(priceChange).toFixed(2)}`;
                priceChangeEl.className = colorClass;
            }
            
            if (priceChangePercentEl) {
                priceChangePercentEl.textContent = `(${priceChange >= 0 ? '+' : ''}${priceChangePercent.toFixed(2)}%)`;
                priceChangePercentEl.className = colorClass;
            }
            
            if (dayHighEl) dayHighEl.textContent = `ê³  ${dayHigh.toFixed(2)}`;
            if (dayLowEl) dayLowEl.textContent = `ì € ${dayLow.toFixed(2)}`;
            if (volumeEl) volumeEl.textContent = `ê±°ë˜ëŸ‰ ${totalVolume.toLocaleString('ko-KR')}`;
            if (marketCapEl) marketCapEl.textContent = `ì‹œê°€ì´ì•¡ --`;
            
            // Update price scale
            updatePriceScale(dayLow, dayHigh);
        }
        
        // Get display name for stock symbol
        function getStockDisplayName(symbol) {
            const stockNames = {
                'AAPL': 'Apple Inc.',
                'GOOGL': 'Alphabet Inc.',
                'MSFT': 'Microsoft Corp.',
                'AMZN': 'Amazon.com Inc.',
                'TSLA': 'Tesla Inc.',
                'META': 'Meta Platforms',
                'NFLX': 'Netflix Inc.',
                'NVDA': 'NVIDIA Corp.'
            };
            return stockNames[symbol] || symbol;
        }
        
        // Update price scale on the right side
        function updatePriceScale(minPrice, maxPrice) {
            const maxPriceEl = document.getElementById('maxPrice');
            const midPriceEl = document.getElementById('midPrice');
            const minPriceEl = document.getElementById('minPrice');
            
            if (maxPriceEl) maxPriceEl.textContent = maxPrice.toFixed(2);
            if (midPriceEl) midPriceEl.textContent = ((maxPrice + minPrice) / 2).toFixed(2);
            if (minPriceEl) minPriceEl.textContent = minPrice.toFixed(2);
        }

        // Load stock data
        async function loadStockData(symbol) {
            if (!symbol) return;

            if (chartLoading) {
                chartLoading.style.display = 'flex';
            }
            if (noStockSelected) {
                noStockSelected.style.display = 'none';
            }

            try {
                // Get number of days for historical data
                const days = chartTimeRange ? parseInt(chartTimeRange.value) || 90 : 90;

                // Show detailed loading information
                console.log(`Loading data for ${symbol}, ${days} days, interval: ${currentInterval}`);

                // Fetch real data from API only - no fallback to mock data
                const data = await fetchRealStockData(symbol, days, currentInterval);
                console.log(`Received ${data.length} price data points`);

                // Also fetch volume data
                const volumeApiData = await fetchRealVolumeData(symbol, days, currentInterval);
                console.log(`Received ${volumeApiData.length} volume data points`);

                stockData = data;
                volumeData = volumeApiData || []; // Handle empty volume data gracefully
                currentStockSymbol = symbol;

                // Ensure all x values in stockData are timestamps (milliseconds)
                stockData = stockData.map(item => ({
                    ...item,
                    x: dateToTimestamp(item.x)
                }));

                // Ensure all x values in volumeData are timestamps (milliseconds)
                volumeData = volumeData.map(item => ({
                    ...item,
                    x: dateToTimestamp(item.x || item.date || item.timestamp)
                }));

                // Validate that we have data
                if (!stockData || stockData.length === 0) {
                    throw new Error('No price data received from API');
                }                // Update Korean candlestick chart
                if (window.koreanCanvasChart) {
                    console.log(`ğŸ›ï¸ Updating Korean chart with ${stockData.length} data points`);
                    // Convert price data to candlestick format
                    const candlestickData = convertToCandlestickData(stockData);
                    window.koreanCanvasChart.updateData(candlestickData);
                } else {
                    console.warn('Korean chart not initialized');
                }

                // Update Korean chart UI
                updateStockInfoDisplay(symbol, stockData);

                // Update volume chart if enabled
                if (showVolumeCheckbox && showVolumeCheckbox.checked && volumeChart) {
                    updateVolumeChart();
                }

                // Update current price display
                const currentPrice = getCurrentPrice();
                if (currentPriceDisplay) {
                    currentPriceDisplay.textContent = `í˜„ì¬ê°€: $${currentPrice.toFixed(2)}`;
                }

                // Update stock info
                if (selectedStockName) {
                    selectedStockName.textContent = getStockDisplayName(symbol);
                }
                if (selectedStockSymbol) {
                    selectedStockSymbol.textContent = symbol;
                }
                if (currentStockPrice) {
                    currentStockPrice.textContent = `$${currentPrice.toFixed(2)}`;
                    currentStockPrice.className = 'text-3xl font-bold text-tv-text';
                }
                if (stockInfo) {
                    stockInfo.classList.remove('hidden');
                }

                // Reset scrollbar to show latest data
                if (chartScrollbar) {
                    chartScrollbar.value = 100;
                }
                chartScrollPosition = 100;
                updateChartView();

                if (chartLoading) {
                    chartLoading.style.display = 'none';
                }

            } catch (error) {
                console.error('Error loading stock data:', error);
                if (chartLoading) {
                    chartLoading.style.display = 'none';
                }

                // Provide more specific error messages
                let errorMessage = 'ë°ì´í„° ë¡œë”©ì— ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤';

                if (error.message.includes('404')) {
                    errorMessage = 'í•´ë‹¹ ì¢…ëª©ì˜ ë°ì´í„°ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤';
                } else if (error.message.includes('500')) {
                    errorMessage = 'ì„œë²„ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤';
                } else if (error.message.includes('Failed to fetch')) {
                    errorMessage = 'ë„¤íŠ¸ì›Œí¬ ì—°ê²°ì„ í™•ì¸í•´ì£¼ì„¸ìš”';
                } else {
                    errorMessage = `ë°ì´í„° ë¡œë”© ì‹¤íŒ¨: ${error.message}`;
                }

                showMessage(errorMessage, 'error');

                // Show the no data state
                if (noStockSelected) {
                    noStockSelected.style.display = 'flex';
                }
                if (stockInfo) {
                    stockInfo.classList.add('hidden');
                }

                // Clear any existing chart data
                if (chart) {
                    chart.data.datasets[0].data = [];
                    chart.data.datasets[1].data = [];
                    chart.update();
                }

                if (volumeChart) {
                    volumeChart.data.datasets[0].data = [];
                    volumeChart.update();
                }

                // Reset variables
                stockData = [];
                volumeData = [];
                currentStockSymbol = '';
            }
        }

        // Fetch real stock data from API
        async function fetchRealStockData(symbol, days, interval = '1d') {
            const market = getMarketType(symbol);

            // First try to get current quote to verify symbol exists
            let currentQuote;
            try {
                const quoteResponse = await fetch(`/api/market-data/quote/${encodeURIComponent(symbol)}/?market=${market}`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                });

                if (quoteResponse.ok) {
                    currentQuote = await quoteResponse.json();
                }
            } catch (error) {
                console.log('Quote fetch failed:', error);
            }

            // Try different endpoints for historical data based on market type
            let historyEndpoints = [];

            if (market === 'crypto') {
                historyEndpoints = [
                    `/api/market-data/coingecko/${symbol}/`,
                    `/api/market-data/crypto/${symbol}/`,
                    `/api/market-data/historical/${symbol}/?market=${market}`,
                ];
            } else {
                historyEndpoints = [
                    `/api/market-data/historical/${symbol}/?market=${market}&days=${days}&interval=${interval}`,
                    `/api/market-data/enhanced/${symbol}/`,
                    `/api/market-data/tiingo/${symbol}/`,
                    `/api/market-data/marketstack/${symbol}/`,
                ];
            }

            // Try each endpoint until one works
            for (const endpoint of historyEndpoints) {
                try {
                    console.log(`Trying endpoint: ${endpoint}`);
                    const response = await fetch(endpoint, {
                        method: 'GET',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                    });

                    if (response.ok) {
                        const data = await response.json();
                        console.log('Raw API response:', data);
                        console.log('Response keys:', Object.keys(data));

                        // Handle different response formats - ONLY REAL API DATA
                        let historicalData = null;

                        console.log('ğŸ” Parsing API response structure:', Object.keys(data));

                        // Check for direct data array format
                        if (data.data && Array.isArray(data.data) && data.data.length > 0) {
                            console.log('ğŸ“Š Found data array with', data.data.length, 'items');
                            console.log('Sample data item:', data.data[0]);
                            
                            historicalData = data.data.map(item => {
                                const dateValue = item.date || item.timestamp || item.time || item.x;
                                const parsedDate = parseDate(dateValue);
                                if (!parsedDate) return null;

                                let price, open, high, low, close, volume;
                                
                                // Check if we have complete OHLC data
                                if (item.open !== undefined && item.high !== undefined && 
                                    item.low !== undefined && item.close !== undefined) {
                                    // Complete OHLC data available
                                    open = parseFloat(item.open);
                                    high = parseFloat(item.high);
                                    low = parseFloat(item.low);
                                    close = parseFloat(item.close);
                                    price = close;
                                    volume = parseFloat(item.volume || Math.random() * 1000000);
                                    
                                    console.log(`ğŸ“Š Full OHLC data: O:${open}, H:${high}, L:${low}, C:${close}`);
                                } else {
                                    // Only single price available - create realistic OHLC from price
                                    price = parseFloat(item.price || item.close || item.value || item.y);
                                    if (!price || price <= 0) return null;
                                    
                                    // Create realistic intraday variation (Â±2%)
                                    const variation = price * 0.02;
                                    const openVariation = (Math.random() - 0.5) * variation;
                                    
                                    open = price + openVariation;
                                    close = price;
                                    high = Math.max(open, close) + (Math.random() * variation * 0.5);
                                    low = Math.min(open, close) - (Math.random() * variation * 0.5);
                                    volume = parseFloat(item.volume || Math.random() * 1000000);
                                    
                                    console.log(`ğŸ“ˆ Generated OHLC from price ${price}: O:${open.toFixed(2)}, H:${high.toFixed(2)}, L:${low.toFixed(2)}, C:${close.toFixed(2)}`);
                                }

                                return {
                                    x: parsedDate,
                                    y: price,
                                    open: open,
                                    high: high,
                                    low: low,
                                    close: close,
                                    volume: volume
                                };
                            }).filter(item => item !== null);
                        }
                        // CoinGecko format
                        else if (data.prices && Array.isArray(data.prices) && data.prices.length > 0) {
                            console.log('ğŸª™ Found CoinGecko format with', data.prices.length, 'price points');
                            historicalData = data.prices.map((item, index) => {
                                const timestamp = Array.isArray(item) ? item[0] : item.timestamp;
                                const price = Array.isArray(item) ? item[1] : item.price;
                                const volume = data.total_volumes && data.total_volumes[index] ?
                                    (Array.isArray(data.total_volumes[index]) ? data.total_volumes[index][1] : data.total_volumes[index]) : 0;

                                const parsedDate = parseDate(timestamp);
                                if (!parsedDate || !price || price <= 0) return null;

                                return {
                                    x: parsedDate,
                                    y: parseFloat(price),
                                    volume: parseFloat(volume)
                                };
                            }).filter(item => item !== null);
                        }
                        // Standard historical_data format
                        else if (data.historical_data && Array.isArray(data.historical_data) && data.historical_data.length > 0) {
                            console.log('ğŸ“ˆ Found historical_data format with', data.historical_data.length, 'items');
                            historicalData = data.historical_data.map(item => {
                                const parsedDate = parseDate(item.date);
                                if (!parsedDate) return null;

                                const price = item.price || item.close || item.value;
                                if (!price || price <= 0) return null;

                                return {
                                    x: parsedDate,
                                    y: parseFloat(price),
                                    volume: parseFloat(item.volume || 0)
                                };
                            }).filter(item => item !== null);
                        }
                        // Skip endpoints that don't provide historical data
                        else {
                            console.log('âš ï¸ No valid historical data format found in response, trying next endpoint');
                            continue;
                        }

                        // Only proceed if we have valid historical data from API
                        if (historicalData && historicalData.length > 0) {
                            console.log(`âœ… Successfully got ${historicalData.length} data points from ${endpoint}`);
                            return historicalData;
                        } else {
                            console.log('âŒ No valid data after parsing, trying next endpoint');
                            continue;
                        }
                    }
                } catch (error) {
                    console.log(`Endpoint ${endpoint} failed:`, error.message);
                    continue;
                }
            }

            // If all endpoints fail, throw error
            // If all endpoints fail, throw error - NO FALLBACK DATA
            throw new Error(`No historical data available for ${symbol}. Tried ${historyEndpoints.length} endpoints.`);
        }

        // Fetch real volume data from API - NO FALLBACK DATA
        async function fetchRealVolumeData(symbol, days, interval = '1d') {
            // Volume data is typically included in the main stock data response
            // So we'll extract it from there instead of making a separate call
            try {
                const market = getMarketType(symbol);

                // For crypto, try CoinGecko first which includes volume
                if (market === 'crypto') {
                    const response = await fetch(`/api/market-data/coingecko/${symbol}/`, {
                        method: 'GET',
                        headers: {
                            'Content-Type': 'application/json',
                        },
                    });

                    if (response.ok) {
                        const data = await response.json();

                        if (data.total_volumes && Array.isArray(data.total_volumes)) {
                            return data.total_volumes.map(item => ({
                                x: new Date(Array.isArray(item) ? item[0] : item.timestamp),
                                y: Array.isArray(item) ? item[1] : item.volume
                            }));
                        }
                    }
                }

                // For stocks, try to get volume from quote API or generate basic volume data
                const quoteResponse = await fetch(`/api/market-data/quote/${encodeURIComponent(symbol)}/?market=${market}`, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                });

                if (quoteResponse.ok) {
                    const quoteData = await quoteResponse.json();
                    console.log('ğŸ“Š Quote data received but no volume generation - using empty array');
                    return []; // Return empty array instead of generating fake data
                }

                // If everything fails, return empty array
                console.log('âŒ No volume data available from APIs, returning empty array');
                return [];

            } catch (error) {
                console.log('âŒ Volume data fetch failed:', error);
                return []; // Return empty array instead of throwing error
            }
        }

        // Get stock display name
        function getStockDisplayName(symbol) {
            const option = stockSelect.querySelector(`option[value="${symbol}"]`);
            return option ? option.textContent.split(' - ')[1] || option.textContent : symbol;
        }

        // Show message
        function showMessage(message, type = 'info') {
            // Create a temporary message element
            const messageEl = document.createElement('div');
            messageEl.className = `fixed top-4 right-4 z-50 p-4 rounded-lg border max-w-sm ${type === 'error' ? 'bg-tv-red/20 border-tv-red/30 text-tv-red' :
                type === 'warning' ? 'bg-orange-500/20 border-orange-500/30 text-orange-500' :
                    'bg-tv-blue/20 border-tv-blue/30 text-tv-blue'
                }`;
            messageEl.innerHTML = `
                <div class="flex items-center space-x-2">
                    <i class="fas fa-${type === 'error' ? 'exclamation-triangle' : type === 'warning' ? 'exclamation-circle' : 'info-circle'}"></i>
                    <span>${message}</span>
                </div>
            `;

            document.body.appendChild(messageEl);

            setTimeout(() => {
                messageEl.remove();
            }, 3000);
        }

        // BOSS FIX: Enhanced Stock Selection Handler
        if (stockSelect) {
            stockSelect.addEventListener('change', function () {
                const symbol = this.value;
                console.log('ğŸ“Š BOSS FIX: Stock selection changed to:', symbol);
                
                if (symbol) {
                    // Clear previous state immediately
                    predictions = [];
                    updatePredictionsList();
                    
                    // Show loading state
                    if (chartLoading) chartLoading.style.display = 'flex';
                    if (noStockSelected) noStockSelected.style.display = 'none';
                    
                    // Load data with error handling
                    loadStockData(symbol).then(() => {
                        console.log('âœ… BOSS FIX: Stock data loaded successfully');
                        
                        // Force chart update
                        if (window.koreanCanvasChart) {
                            window.koreanCanvasChart.updateData(convertToCandlestickData(stockData));
                        }
                        
                        // Update stock info display
                        updateStockInfoDisplay(symbol, stockData);
                        
                        // Show confirmation to user
                        showMessage('ì£¼ì‹ì´ ì„±ê³µì ìœ¼ë¡œ ì„ íƒë˜ì—ˆìŠµë‹ˆë‹¤: ' + symbol, 'success');
                        
                    }).catch(error => {
                        console.error('âŒ BOSS FIX: Stock loading failed:', error);
                        showMessage('ì£¼ì‹ ë°ì´í„°ë¥¼ ë¶ˆëŸ¬ì˜¤ëŠ”ë° ì‹¤íŒ¨í–ˆìŠµë‹ˆë‹¤', 'error');
                    });
                } else {
                    // Clear everything when no stock selected
                    if (stockInfo) stockInfo.classList.add('hidden');
                    if (noStockSelected) noStockSelected.style.display = 'flex';
                    if (chartLoading) chartLoading.style.display = 'none';
                    
                    currentStockSymbol = '';
                    predictions = [];
                    updatePredictionsList();
                    
                    // Clear chart data
                    if (window.koreanCanvasChart) {
                        window.koreanCanvasChart.updateData([]);
                    }
                    
                    console.log('ğŸ“Š BOSS FIX: Stock selection cleared');
                }
            });
            
            // Also add click handler for stock options
            stockSelect.addEventListener('click', function() {
                console.log('ğŸ“Š BOSS FIX: Stock dropdown clicked');
            });
        }

        // Chart time range handler
        if (chartTimeRange) {
            chartTimeRange.addEventListener('change', function () {
                if (currentStockSymbol) {
                    loadStockData(currentStockSymbol);
                }
            });
        }

        // Stock search functionality
        stockSearch.addEventListener('input', function () {
            const searchTerm = this.value.toLowerCase();
            const options = stockSelect.querySelectorAll('option');

            options.forEach(option => {
                if (option.value === '') return;

                const text = option.textContent.toLowerCase();
                const value = option.value.toLowerCase();

                if (text.includes(searchTerm) || value.includes(searchTerm)) {
                    option.style.display = '';
                } else {
                    option.style.display = 'none';
                }
            });
        });

        // Enhanced stock search input functionality
        if (stockSearchInput) {
            stockSearchInput.addEventListener('input', function () {
                const searchTerm = this.value.toLowerCase();
                const options = stockSelect.querySelectorAll('option');
                let matchFound = false;

            options.forEach(option => {
                if (option.value === '') return;

                const text = option.textContent.toLowerCase();
                const value = option.value.toLowerCase();

                if (text.includes(searchTerm) || value.includes(searchTerm)) {
                    if (!matchFound) {
                        // Auto-select first match
                        stockSelect.value = option.value;
                        stockSelect.dispatchEvent(new Event('change'));
                        matchFound = true;
                    }
                }
            });
        });

            // BOSS REQUIREMENT: Add Enter key handler for duplicate stock selection refresh
            // "ì‚¼ì„±ì „ìë¼ê³  ì¤‘ë³µì„ ì…ë ¥í•˜ê³  ì—”í„°í‚¤ë¥¼ ëˆŒë ¤ë„ ì¤‘ë³µì´ ë³€í•˜ì§€ ì•ŠëŠ”ë‹¤"
            stockSearchInput.addEventListener('keydown', function (e) {
                if (e.key === 'Enter' || e.keyCode === 13) {
                    e.preventDefault();
                    console.log('ğŸ”„ Boss requirement: Enter key pressed, forcing chart refresh for duplicate stock');
                    
                    // Force refresh even with same stock selection
                    const currentValue = stockSelect.value;
                    if (currentValue) {
                        // Clear and reset to trigger change event
                        stockSelect.value = '';
                        stockSelect.value = currentValue;
                        stockSelect.dispatchEvent(new Event('change'));
                        
                        console.log('âœ… Chart refreshed for stock:', currentValue);
                    } else {
                        console.log('âš ï¸ No stock selected to refresh');
                    }
                }
            });
        }

        // Time interval button handlers
        timeIntervalBtns.forEach(btn => {
            btn.addEventListener('click', function () {
                // Update active button
                timeIntervalBtns.forEach(b => {
                    b.classList.remove('bg-tv-blue', 'text-white');
                    b.classList.add('text-tv-text-secondary', 'hover:text-tv-text', 'hover:bg-tv-light');
                });

                this.classList.add('bg-tv-blue', 'text-white');
                this.classList.remove('text-tv-text-secondary', 'hover:text-tv-text', 'hover:bg-tv-light');

                currentInterval = this.dataset.interval;

                // Update chart time unit based on interval
                if (chart) {
                    let timeUnit = 'day';
                    switch (currentInterval) {
                        case '1m':
                        case '5m':
                            timeUnit = 'minute';
                            break;
                        case '1h':
                            timeUnit = 'hour';
                            break;
                        case '1d':
                            timeUnit = 'day';
                            break;
                        case '1wk':
                            timeUnit = 'week';
                            break;
                        case '1mo':
                            timeUnit = 'month';
                            break;
                    }

                    chart.options.scales.x.time.unit = timeUnit;
                    chart.update();
                }

                // Reload data with new interval if stock is selected
                if (currentStockSymbol) {
                    loadStockData(currentStockSymbol);
                }
            });
        });

        // BOSS REQUIREMENT: SIMPLE KOREAN BUTTONS FUNCTIONALITY
        const simpleTimeBtns = document.querySelectorAll('.simple-time-btn');
        simpleTimeBtns.forEach(btn => {
            btn.addEventListener('click', function () {
                // Remove active class from all simple time buttons
                simpleTimeBtns.forEach(b => b.classList.remove('active'));
                
                // Add active class to clicked button
                this.classList.add('active');
                
                const period = this.dataset.period;
                const interval = this.dataset.interval;
                console.log('Boss 5-button clicked:', period, interval);
                
                // BOSS REQUIREMENT: Exact 5 intervals only
                let newInterval = interval;
                let koreanChartInterval = interval; // For Korean chart compatibility
                let timeUnit = 'day';
                
                switch (period) {
                    case 'hourly': // 1ì‹œê°„ - One bar = 1 hour
                        newInterval = '1h';
                        koreanChartInterval = '1h';
                        timeUnit = 'hour';
                        break;
                    case 'daily': // ì¼ì¼ - One bar = 1 day  
                        newInterval = '1d';
                        koreanChartInterval = '1d';
                        timeUnit = 'day';
                        break;
                    case 'weekly': // ì£¼ê°„ - One bar = 7 days (1 week)
                        newInterval = '1w';
                        koreanChartInterval = '1wk'; // Korean chart expects '1wk'
                        timeUnit = 'week';
                        break;
                    case 'monthly': // ì›”ê°„ - One bar = 1 month
                        newInterval = '1M';
                        koreanChartInterval = '1mo'; // Korean chart expects '1mo'
                        timeUnit = 'month';
                        break;
                    case 'yearly': // ë…„ê°„ - One bar = 1 year
                        newInterval = '1Y';
                        koreanChartInterval = '1y';
                        timeUnit = 'year';
                        break;
                }
                
                // Update current interval and chart time unit
                currentInterval = newInterval;
                
                // BOSS FIX: Update Korean chart with proper interval
                if (window.koreanCanvasChart && typeof window.koreanCanvasChart.setTimeInterval === 'function') {
                    window.koreanCanvasChart.setTimeInterval(koreanChartInterval);
                    console.log(`âœ… Korean chart time interval updated to: ${koreanChartInterval}`);
                }
                
                // Update Chart.js chart time unit immediately
                if (chart) {
                    chart.options.scales.x.time.unit = timeUnit;
                    chart.update();
                }
                
                if (currentStockSymbol) {
                    loadStockData(currentStockSymbol);
                }
                
                console.log(`Boss requirement: ${period} selected - Chart bars now represent ${timeUnit}s`);
            });
        });

        // Chart scrollbar handler - Enhanced for past/present/future navigation
        const chartTimeScrollbar = document.getElementById('chartTimeScrollbar');
        const scrollToPastBtn = document.getElementById('scrollToPast');
        const scrollToFutureBtn = document.getElementById('scrollToFuture');
        const timePositionEl = document.getElementById('timePosition');
        
        if (chartTimeScrollbar) {
            chartTimeScrollbar.addEventListener('input', function () {
                chartScrollPosition = parseInt(this.value);
                updateChartTimeView();
                updateTimePositionDisplay();
            });
        }
        
        if (scrollToPastBtn) {
            scrollToPastBtn.addEventListener('click', () => {
                chartScrollPosition = Math.max(0, chartScrollPosition - 10);
                chartTimeScrollbar.value = chartScrollPosition;
                updateChartTimeView();
                updateTimePositionDisplay();
            });
        }
        
        if (scrollToFutureBtn) {
            scrollToFutureBtn.addEventListener('click', () => {
                chartScrollPosition = Math.min(100, chartScrollPosition + 10);
                chartTimeScrollbar.value = chartScrollPosition;
                updateChartTimeView();
                updateTimePositionDisplay();
            });
        }
        
        // Update time position display
        function updateTimePositionDisplay() {
            if (!timePositionEl) return;
            
            if (chartScrollPosition < 30) {
                timePositionEl.textContent = 'ê³¼ê±°';
            } else if (chartScrollPosition > 70) {
                timePositionEl.textContent = 'ë¯¸ë˜';
            } else {
                timePositionEl.textContent = 'í˜„ì¬';
            }
        }
        
        // Enhanced chart view update with future date support
        function updateChartTimeView() {
            if (!window.koreanCanvasChart || !stockData || stockData.length === 0) return;
            
            // Generate future dates if scrolling to future
            if (chartScrollPosition > 70 && futureData.length === 0) {
                generateFutureDates();
            }
            
            // Combine historical and future data
            const allData = [...stockData, ...futureData];
            const totalDataPoints = allData.length;
            const visiblePoints = 25; // FIXED NUMBER - ALWAYS 25 candlesticks for consistent spacing
            
            // Calculate visible range based on scroll position
            let startIndex, endIndex;
            
            if (chartScrollPosition <= 50) {
                // Showing past data
                const maxStartIndex = Math.max(0, stockData.length - visiblePoints);
                startIndex = Math.floor((chartScrollPosition / 50) * maxStartIndex);
                endIndex = Math.min(startIndex + visiblePoints, stockData.length);
            } else {
                // Showing recent to future data
                const pastPoints = Math.floor(visiblePoints * 0.3); // 30% past data
                const futurePoints = visiblePoints - pastPoints; // 70% future data
                
                startIndex = Math.max(0, stockData.length - pastPoints);
                endIndex = Math.min(startIndex + visiblePoints, totalDataPoints);
            }
            
            // BOSS REQUIREMENT: Ensure we always show exactly 25 candlesticks
            if (endIndex - startIndex < visiblePoints && startIndex > 0) {
                startIndex = Math.max(0, endIndex - visiblePoints);
            } else if (endIndex - startIndex < visiblePoints) {
                endIndex = Math.min(totalDataPoints, startIndex + visiblePoints);
            }
            
            // Get visible data range
            const visibleData = allData.slice(startIndex, endIndex);
            
            // Convert to candlestick format and update Korean chart
            const candlestickData = convertToCandlestickData(visibleData);
            window.koreanCanvasChart.updateData(candlestickData);
            
            console.log(`ğŸ“Š Time navigation: Position ${chartScrollPosition}%, showing ${visibleData.length} candles from index ${startIndex}-${endIndex}`);
        }
        
        // Generate future dates for navigation
        function generateFutureDates() {
            if (!stockData || stockData.length === 0) return;
            
            futureData = [];
            const lastDate = new Date(stockData[stockData.length - 1].x);
            const lastPrice = stockData[stockData.length - 1].y;
            
            // Generate 30 future dates
            for (let i = 1; i <= 30; i++) {
                const futureDate = new Date(lastDate);
                
                // Add days based on current interval
                if (currentInterval === '1d') {
                    futureDate.setDate(futureDate.getDate() + i);
                } else if (currentInterval === '1wk') {
                    futureDate.setDate(futureDate.getDate() + (i * 7));
                } else if (currentInterval === '1mo') {
                    futureDate.setMonth(futureDate.getMonth() + i);
                } else {
                    futureDate.setDate(futureDate.getDate() + i);
                }
                
                futureData.push({
                    x: futureDate.getTime(),
                    y: lastPrice, // Keep same price for future (prediction points will overlay)
                    isFuture: true
                });
            }
            
            console.log(`ğŸ”® Generated ${futureData.length} future dates for navigation`);
        }

        // Update chart view based on scroll position
        function updateChartView() {
            if (!chart || stockData.length === 0) return;

            const totalDataPoints = stockData.length;
            const visiblePoints = Math.min(50, totalDataPoints); // Show maximum 50 points at once

            // Calculate the start index based on scroll position
            const maxStartIndex = Math.max(0, totalDataPoints - visiblePoints);
            const startIndex = Math.floor((chartScrollPosition / 100) * maxStartIndex);
            const endIndex = Math.min(startIndex + visiblePoints, totalDataPoints);

            // Update chart data to show only the selected range
            const visibleData = stockData.slice(startIndex, endIndex);
            chart.data.datasets[0].data = visibleData;

            // Add future dates for predictions (extend 30 days into future)
            if (chartScrollPosition === 100) {
                const lastDate = new Date(stockData[stockData.length - 1].x);
                const futureData = [];
                for (let i = 1; i <= 30; i++) {
                    const futureDate = new Date(lastDate);
                    futureDate.setDate(futureDate.getDate() + i);
                    futureData.push({
                        x: futureDate,
                        y: null // No price data for future dates
                    });
                }
                chart.data.datasets[0].data = [...visibleData, ...futureData];
            }

            chart.update('none');

            // Update volume chart if visible
            if (volumeChart && showVolumeCheckbox.checked) {
                const visibleVolumeData = volumeData.slice(startIndex, endIndex);
                volumeChart.data.datasets[0].data = visibleVolumeData;
                volumeChart.update('none');
            }
        }

        // Volume toggle handler
        if (showVolumeCheckbox) {
            showVolumeCheckbox.addEventListener('change', function () {
                if (this.checked) {
                    volumeContainer.style.display = 'block';
                    updateVolumeChart();
                } else {
                    volumeContainer.style.display = 'none';
                }
            });
        }        // Update volume chart with current data
        function updateVolumeChart() {
            if (!volumeChart || volumeData.length === 0) return;

            volumeChart.data.datasets[0].data = volumeData;
            volumeChart.update();
        }

        // Reset zoom handler
        if (resetZoomBtn) {
            resetZoomBtn.addEventListener('click', function () {
                if (chart) {
                    chart.resetZoom();
                    showMessage('ì°¨íŠ¸ ì¤Œì´ ë¦¬ì…‹ë˜ì—ˆìŠµë‹ˆë‹¤.', 'info');
                }
            });
        }

        // Delete prediction from tooltip
        if (deletePredictionBtn) {
            deletePredictionBtn.addEventListener('click', function () {
                if (hoveredPredictionPoint) {
                    removePrediction(hoveredPredictionPoint.id);
                    hidePredictionTooltip();
                    showMessage('ì˜ˆì¸¡ì´ ì‚­ì œë˜ì—ˆìŠµë‹ˆë‹¤.', 'info');
                }
            });
        }

        // Form submission handler
        predictionForm.addEventListener('submit', async function (e) {
            e.preventDefault();

            if (predictions.length === 0) {
                showMessage('ì°¨íŠ¸ì—ì„œ ì˜ˆì¸¡ì„ ì„¤ì •í•´ì£¼ì„¸ìš”.', 'warning');
                return;
            }

            // Disable submit button
            submitButton.disabled = true;
            submitButtonText.textContent = 'ë°œí–‰ ì¤‘...';
            submitButton.querySelector('i').className = 'fas fa-spinner fa-spin mr-2';

            try {
                const currentPrice = getCurrentPrice();

                // Create predictions for each point
                for (const prediction of predictions) {
                    const formData = {
                        stock_symbol: currentStockSymbol,
                        current_price: currentPrice,
                        predicted_price: prediction.price,
                        target_date: new Date(prediction.date).toISOString().split('T')[0],
                        reasoning: `Chart-based prediction for ${currentStockSymbol}`,
                        confidence: 75
                    };

                    console.log('Submitting prediction:', formData);

                    const response = await fetch('/api/charts/predictions/', {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json',
                            'X-CSRFToken': getCookie('csrftoken') || '',
                        },
                        body: JSON.stringify(formData)
                    });

                    if (!response.ok) {
                        const error = await response.json();
                        throw new Error(error.detail || 'Failed to create prediction');
                    }
                }

                // Show success message
                predictionForm.style.display = 'none';
                successMessage.classList.remove('hidden');

            } catch (error) {
                console.error('Error submitting predictions:', error);
                showMessage('ì˜ˆì¸¡ ë°œí–‰ ì¤‘ ì˜¤ë¥˜ê°€ ë°œìƒí–ˆìŠµë‹ˆë‹¤: ' + error.message, 'error');
            } finally {
                // Re-enable submit button
                submitButton.disabled = false;
                submitButtonText.textContent = 'ì˜ˆì¸¡ ë°œí–‰í•˜ê¸°';
                submitButton.querySelector('i').className = 'fas fa-rocket mr-2';
            }
        });

        // Initialize when page loads
        // BOSS REQUIREMENT: INSTANT ZOOM - SIMPLE AND FAST
        function setupInstantZoom() {
            const chartContainer = document.getElementById('chartContainer');
            if (!chartContainer) return;
            
            // Remove any existing wheel listeners to avoid conflicts
            const oldHandler = chartContainer.onwheel;
            if (oldHandler) chartContainer.removeEventListener('wheel', oldHandler);
            
            // Add super simple, instant wheel handler
            chartContainer.addEventListener('wheel', function(e) {
                if (e.ctrlKey || e.metaKey) {
                    e.preventDefault();
                    
                    // INSTANT ZOOM CALCULATION
                    const factor = e.deltaY > 0 ? 0.9 : 1.1;
                    globalZoomLevel = Math.max(0.1, Math.min(5.0, globalZoomLevel * factor));
                    
                    // Update display instantly
                    const zoomDisplay = document.getElementById('zoomDisplay');
                    if (zoomDisplay) zoomDisplay.textContent = `Zoom: ${Math.round(globalZoomLevel * 100)}%`;
                    
                    // Instant chart redraw
                    if (window.koreanCanvasChart && typeof window.koreanCanvasChart.draw === 'function') {
                        window.koreanCanvasChart.draw();
                    }
                }
            }, { passive: false });
        }

        // Initialize chart and setup instant zoom
        document.addEventListener('DOMContentLoaded', function () {
            // Only initialize if chart doesn't exist
            if (!chart) {
                initializeChart();
            }
            
            // BOSS REQUIREMENT: Setup instant zoom
            setupInstantZoom();
            
            noStockSelected.style.display = 'flex';
            chartLoading.style.display = 'none';
            console.log('Interactive prediction chart initialized');
        });

        // CSRF Token helper function
        function getCookie(name) {
            let cookieValue = null;
            if (document.cookie && document.cookie !== '') {
                const cookies = document.cookie.split(';');
                for (let i = 0; i < cookies.length; i++) {
                    const cookie = cookies[i].trim();
                    if (cookie.substring(0, name.length + 1) === (name + '=')) {
                        cookieValue = decodeURIComponent(cookie.substring(name.length + 1));
                        break;
                    }
                }
            }
            return cookieValue;
        }

        // Reset form function
        function resetForm() {
            predictionForm.reset();
            stockInfo.classList.add('hidden');
            predictionsPanel.classList.add('hidden');
            successMessage.classList.add('hidden');
            predictionForm.style.display = 'block';
            predictions = [];
            currentStockSymbol = '';
            if (chart) {
                chart.data.datasets[0].data = [];
                chart.data.datasets[1].data = [];
                chart.update();
            }
            noStockSelected.style.display = 'flex';
        }

        // Mobile menu functions
        function toggleMobileMenu() {
            const mobileMenu = document.getElementById('mobileMenu');
            const mobileMenuButton = document.getElementById('mobileMenuButton');

            if (mobileMenu.classList.contains('translate-x-full')) {
                // Open menu
                mobileMenu.classList.remove('translate-x-full');
                mobileMenu.classList.add('translate-x-0');
                mobileMenuButton.classList.add('menu-open');
                document.body.style.overflow = 'hidden';
            } else {
                // Close menu
                mobileMenu.classList.remove('translate-x-0');
                mobileMenu.classList.add('translate-x-full');
                mobileMenuButton.classList.remove('menu-open');
                document.body.style.overflow = 'auto';
            }
        }

        // Login modal function (placeholder)
        function showLoginModal() {
            alert('ë¡œê·¸ì¸ ê¸°ëŠ¥ì€ ê³§ êµ¬í˜„ë  ì˜ˆì •ì…ë‹ˆë‹¤.');
        }

        // Add hamburger menu animation styles
        const style = document.createElement('style');
        style.textContent = `
            .hamburger-line {
                transition: all 0.3s cubic-bezier(0.68, -0.55, 0.265, 1.55);
            }
            
            .menu-open .hamburger-line:nth-child(1) {
                transform: rotate(45deg) translate(6px, 6px);
            }
            
            .menu-open .hamburger-line:nth-child(2) {
                opacity: 0;
                transform: scale(0);
            }
            
            .menu-open .hamburger-line:nth-child(3) {
                transform: rotate(-45deg) translate(6px, -6px);
            }

            /* Time interval buttons */
            .time-interval-btn {
                color: #868993;
                background: transparent;
            }
            
            .time-interval-btn:hover {
                color: #d1d4dc;
                background: rgba(42, 46, 57, 0.7);
            }
            
            .time-interval-btn.active {
                background: #2962ff !important;
                color: white !important;
            }

            /* Custom scrollbar styling */
            #chartScrollbar, #chartTimeScrollbar {
                background: transparent;
                outline: none;
            }
            
            #chartScrollbar::-webkit-slider-track, #chartTimeScrollbar::-webkit-slider-track {
                background: #363a45;
                border-radius: 4px;
                height: 8px;
            }
            
            #chartScrollbar::-webkit-slider-thumb, #chartTimeScrollbar::-webkit-slider-thumb {
                appearance: none;
                width: 20px;
                height: 8px;
                border-radius: 4px;
                background: #2962ff;
                cursor: pointer;
            }
            
            #chartScrollbar::-webkit-slider-thumb:hover, #chartTimeScrollbar::-webkit-slider-thumb:hover {
                background: #1e40af;
            }
            
            /* Time scrollbar specific styling */
            #chartTimeScrollbar {
                height: 8px;
            }
            
            #chartTimeScrollbar::-webkit-slider-track {
                background: linear-gradient(to right, #4CAF50 0%, #FFC107 50%, #FF5722 100%);
                height: 6px;
            }
            
            #chartTimeScrollbar::-webkit-slider-thumb {
                width: 16px;
                height: 16px;
                border-radius: 50%;
                background: #FFFFFF;
                border: 2px solid #2962ff;
                box-shadow: 0 2px 4px rgba(0,0,0,0.2);
            }

            /* Prediction tooltip */
            #predictionTooltip {
                pointer-events: auto;
                backdrop-filter: blur(10px);
                box-shadow: 0 10px 25px rgba(0, 0, 0, 0.3);
            }
            
            #predictionTooltip.hidden {
                display: none !important;
            }

            /* Enhanced grid lines */
            .chartjs-render-monitor {
                position: relative;
            }

            /* Volume chart styling */
            #volumeContainer {
                transition: all 0.3s ease;
            }
            
            #volumeContainer.hidden {
                height: 0 !important;
                overflow: hidden;
            }

            /* Chart container responsive styles - Enhanced for mobile */
            @media (max-width: 640px) {
                #chartContainer .relative:first-child {
                    height: 300px !important;
                    min-height: 250px !important;
                }
                
                #volumeContainer {
                    height: 60px !important;
                    min-height: 50px !important;
                }
                
                .chart-controls {
                    flex-direction: column;
                    gap: 4px;
                }
                
                .time-interval-btn {
                    font-size: 10px;
                    padding: 4px 8px;
                    min-width: 24px;
                }
                
                #predictionTooltip {
                    font-size: 11px;
                    padding: 6px;
                    max-width: 200px;
                }
                
                /* Mobile-specific chart optimizations */
                canvas {
                    touch-action: pan-x pan-y;
                }
                
                /* Ensure buttons are touch-friendly */
                button {
                    min-height: 32px;
                    touch-action: manipulation;
                }
                
                /* Scrollbar touch optimization */
                #scrollbarThumb {
                    min-height: 16px;
                }
            }
            
            @media (min-width: 641px) and (max-width: 768px) {
                #chartContainer .relative:first-child {
                    height: 350px !important;
                }
                
                #volumeContainer {
                    height: 80px !important;
                }
                
                .chart-controls {
                    flex-direction: column;
                    gap: 8px;
                }
                
                .time-interval-btn {
                    font-size: 12px;
                    padding: 8px 12px;
                }
                
                #predictionTooltip {
                    font-size: 12px;
                    padding: 8px;
                }
            }

            /* Touch-friendly interactions on mobile devices */
            @media (hover: none) and (pointer: coarse) {
                canvas {
                    cursor: default !important;
                    touch-action: pan-x pan-y;
                }
                
                .prediction-point {
                    touch-action: manipulation;
                }
                
                #chartScrollbar {
                    height: 12px;
                }
                
                #chartScrollbar::-webkit-slider-thumb {
                    height: 12px;
                    width: 24px;
                }
            }

            /* Enhanced search input */
            #stockSearchInput:focus {
                box-shadow: 0 0 0 2px rgba(41, 98, 255, 0.2);
                transform: translateY(-1px);
            }

            /* Button hover effects */
            .time-interval-btn, button[type="button"] {
                transition: all 0.2s ease;
            }
            
            button[type="button"]:hover {
                transform: translateY(-1px);
                box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            }

            /* Volume bars animation */
            #volumeChart {
                transition: opacity 0.3s ease;
            }

            /* Prediction points enhanced styling */
            .chartjs-render-monitor canvas {
                border-radius: 0 0 8px 8px;
            }
        `;
        document.head.appendChild(style);

        // Check API status on page load
        document.addEventListener('DOMContentLoaded', function () {
            checkApiStatus();
        });

        // API Status Functions
        async function checkApiStatus() {
            const apiStatusContent = document.getElementById('apiStatusContent');
            apiStatusContent.innerHTML = `
                <div class="text-center text-tv-text-secondary py-4">
                    <i class="fas fa-spinner fa-spin text-tv-blue text-xl mb-2"></i>
                    <p>API ìƒíƒœ í™•ì¸ ì¤‘...</p>
                </div>
            `;

            try {
                // Use the comprehensive health endpoint
                const response = await fetch('/api/market-data/health/', {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' }
                });

                if (response.ok) {
                    const healthData = await response.json();
                    displayEnhancedApiStatus(healthData);
                } else {
                    // Fallback to individual API tests
                    await fallbackApiStatusCheck();
                }

            } catch (error) {
                console.error('API status check failed:', error);
                await fallbackApiStatusCheck();
            }
        }

        function displayEnhancedApiStatus(healthData) {
            const apiStatusContent = document.getElementById('apiStatusContent');

            const overallStatusIcon = getStatusIcon(healthData.overall_status);
            const overallStatusColor = getStatusColor(healthData.overall_status);

            let html = `
                <div class="space-y-4">
                    <!-- Overall Status -->
                    <div class="bg-tv-card rounded-lg border border-tv-border p-4">
                        <div class="flex items-center justify-between">
                            <div class="flex items-center space-x-3">
                                <span class="text-2xl">${overallStatusIcon}</span>
                                <div>
                                    <h3 class="text-lg font-semibold text-tv-text">ì „ì²´ API ìƒíƒœ</h3>
                                    <p class="text-sm ${overallStatusColor}">
                                        ${healthData.overall_status === 'healthy' ? 'ì •ìƒ' :
                    healthData.overall_status === 'degraded' ? 'ì„±ëŠ¥ ì €í•˜' : 'ì‹¬ê°í•œ ë¬¸ì œ'}
                                    </p>
                                </div>
                            </div>
                            <div class="text-right">
                                <div class="text-lg font-bold text-tv-text">${healthData.online_apis}</div>
                                <div class="text-sm text-tv-text-secondary">APIs í™œì„±</div>
                            </div>
                        </div>
                        
                        <div class="mt-3 flex items-center space-x-4 text-sm text-tv-text-secondary">
                            <div>ìƒíƒœ: ${healthData.health_percentage}%</div>
                            <div>í‰ê·  ì‘ë‹µì‹œê°„: ${healthData.average_response_time_ms}ms</div>
                            <div>ë§ˆì§€ë§‰ í™•ì¸: ${new Date(healthData.last_updated).toLocaleTimeString()}</div>
                        </div>
                    </div>

                    <!-- API Details -->
                    <div class="grid grid-cols-2 gap-3">
            `;

            // Add individual API statuses
            Object.entries(healthData.api_details).forEach(([apiName, details]) => {
                const statusIcon = getApiStatusIcon(details.status);
                const statusColor = getApiStatusColor(details.status);
                const statusText = getApiStatusText(details.status);

                html += `
                    <div class="bg-tv-light rounded-lg border border-tv-border p-3">
                        <div class="flex items-center justify-between">
                            <div class="flex items-center space-x-2">
                                <span class="text-lg">${statusIcon}</span>
                                <div>
                                    <div class="font-medium text-tv-text capitalize">${apiName}</div>
                                    <div class="text-xs ${statusColor}">${statusText}</div>
                                </div>
                            </div>
                            <div class="text-right text-xs text-tv-text-secondary">
                                ${details.response_time_ms ? `${details.response_time_ms}ms` : '-'}
                            </div>
                        </div>
                        ${details.error ? `<div class="mt-2 text-xs text-tv-red">${details.error}</div>` : ''}
                    </div>
                `;
            });

            html += `
                    </div>

                    <!-- Recommendations -->
                    ${healthData.recommendations && healthData.recommendations.length > 0 ? `
                    <div class="bg-tv-card rounded-lg border border-tv-border p-4">
                        <h4 class="text-sm font-semibold text-tv-text mb-2">ê¶Œì¥ì‚¬í•­</h4>
                        <ul class="space-y-1">
                            ${healthData.recommendations.map(rec => `
                                <li class="text-xs text-tv-text-secondary flex items-start space-x-2">
                                    <span class="text-tv-blue">â€¢</span>
                                    <span>${rec}</span>
                                </li>
                            `).join('')}
                        </ul>
                    </div>
                    ` : ''}
                </div>
            `;

            apiStatusContent.innerHTML = html;
        }

        async function fallbackApiStatusCheck() {
            const apiStatusContent = document.getElementById('apiStatusContent');

            try {
                // Test individual APIs as fallback
                const apiTests = [
                    { name: 'Finnhub', endpoint: '/api/market-data/quote/AAPL/?market=us_stock', type: 'stocks' },
                    { name: 'CoinGecko', endpoint: '/api/market-data/coingecko/BTC/', type: 'crypto' },
                    { name: 'Alpha Vantage', endpoint: '/api/market-data/quote/GOOGL/?market=us_stock', type: 'stocks' },
                    { name: 'Marketstack', endpoint: '/api/market-data/quote/MSFT/?market=us_stock', type: 'stocks' },
                    { name: 'Tiingo', endpoint: '/api/market-data/quote/AMZN/?market=us_stock', type: 'stocks' },
                    { name: 'Twelve Data', endpoint: '/api/market-data/quote/TSLA/?market=us_stock', type: 'stocks' }
                ];

                const results = await Promise.allSettled(
                    apiTests.map(async (api) => {
                        const startTime = Date.now();
                        try {
                            const response = await fetch(api.endpoint, {
                                method: 'GET',
                                headers: { 'Content-Type': 'application/json' }
                            });
                            const responseTime = Date.now() - startTime;
                            return {
                                ...api,
                                status: response.ok ? 'success' : 'error',
                                responseTime: responseTime,
                                statusCode: response.status
                            };
                        } catch (error) {
                            return {
                                ...api,
                                status: 'error',
                                responseTime: Date.now() - startTime,
                                error: error.message
                            };
                        }
                    })
                );

                displayBasicApiStatus(results.map(r => r.value || r.reason));

            } catch (error) {
                console.error('Fallback API status check failed:', error);
                apiStatusContent.innerHTML = `
                    <div class="text-center text-tv-red py-4">
                        <i class="fas fa-exclamation-triangle text-xl mb-2"></i>
                        <p>API ìƒíƒœ í™•ì¸ ì‹¤íŒ¨</p>
                    </div>
                `;
            }
        }

        function displayApiStatus(results) {
            const apiStatusContent = document.getElementById('apiStatusContent');
            const workingApis = results.filter(r => r.status === 'success').length;
            const totalApis = results.length;

            let statusHtml = `
                <div class="mb-4 p-3 rounded-lg ${workingApis > totalApis / 2 ? 'bg-tv-green/20 border border-tv-green/30' : 'bg-tv-red/20 border border-tv-red/30'}">
                    <div class="flex items-center justify-between">
                        <span class="font-semibold ${workingApis > totalApis / 2 ? 'text-tv-green' : 'text-tv-red'}">
                            <i class="fas fa-${workingApis > totalApis / 2 ? 'check-circle' : 'exclamation-circle'} mr-2"></i>
                            API ìƒíƒœ: ${workingApis}/${totalApis} ì‘ë™ ì¤‘
                        </span>
                        <span class="text-sm text-tv-text-secondary">
                            ${new Date().toLocaleTimeString('ko-KR')} ì—…ë°ì´íŠ¸
                        </span>
                    </div>
                </div>
                
                <div class="space-y-2">
            `;

            results.forEach(api => {
                const statusIcon = api.status === 'success' ?
                    '<i class="fas fa-check-circle text-tv-green"></i>' :
                    '<i class="fas fa-times-circle text-tv-red"></i>';

                const statusText = api.status === 'success' ? 'ì •ìƒ' : 'ì˜¤ë¥˜';
                const statusClass = api.status === 'success' ? 'text-tv-green' : 'text-tv-red';

                statusHtml += `
                    <div class="flex items-center justify-between p-3 bg-tv-light rounded-lg">
                        <div class="flex items-center space-x-3">
                            ${statusIcon}
                            <span class="font-medium text-tv-text">${api.name}</span>
                            <span class="text-xs px-2 py-1 rounded-full bg-tv-blue/20 text-tv-blue">${api.type}</span>
                        </div>
                        <div class="text-right">
                            <span class="${statusClass} text-sm font-medium">${statusText}</span>
                            ${api.statusCode ? `<span class="text-xs text-tv-text-secondary ml-2">(${api.statusCode})</span>` : ''}
                        </div>
                    </div>
                `;
            });

            statusHtml += '</div>';
            apiStatusContent.innerHTML = statusHtml;
        }

        function displayBasicApiStatus(results) {
            const apiStatusContent = document.getElementById('apiStatusContent');
            const workingApis = results.filter(api => api.status === 'success').length;
            const totalApis = results.length;

            let html = `
                <div class="text-center mb-4">
                    <div class="text-lg font-bold text-tv-text">${workingApis}/${totalApis} APIs í™œì„±</div>
                    <div class="text-sm text-tv-text-secondary">ë§ˆì§€ë§‰ í™•ì¸: ${new Date().toLocaleTimeString()}</div>
                </div>
                <div class="space-y-3">
            `;

            results.forEach(api => {
                const statusIcon = api.status === 'success' ? 'âœ…' : 'âŒ';
                const statusColor = api.status === 'success' ? 'text-tv-green' : 'text-tv-red';

                html += `
                    <div class="flex items-center justify-between p-3 bg-tv-light rounded-lg">
                        <div class="flex items-center space-x-3">
                            <span class="text-lg">${statusIcon}</span>
                            <span class="font-medium text-tv-text">${api.name}</span>
                            <span class="text-xs px-2 py-1 rounded-full bg-tv-blue/20 text-tv-blue">${api.type}</span>
                        </div>
                        <div class="text-right">
                            <span class="${statusColor} text-sm font-medium">
                                ${api.status === 'success' ? 'ì •ìƒ' : 'ì˜¤ë¥˜'}
                            </span>
                            ${api.responseTime ? `<div class="text-xs text-tv-text-secondary">${api.responseTime}ms</div>` : ''}
                            ${api.error ? `<div class="text-xs text-tv-red mt-1">${api.error.substring(0, 30)}...</div>` : ''}
                        </div>
                    </div>
                `;
            });

            html += `</div>`;
            apiStatusContent.innerHTML = html;
        }

        // Helper functions for enhanced status display
        function getStatusIcon(status) {
            switch (status) {
                case 'healthy': return 'âœ…';
                case 'degraded': return 'âš ï¸';
                case 'critical': return 'ğŸ”´';
                default: return 'â“';
            }
        }

        function getStatusColor(status) {
            switch (status) {
                case 'healthy': return 'text-tv-green';
                case 'degraded': return 'text-yellow-500';
                case 'critical': return 'text-tv-red';
                default: return 'text-tv-text-secondary';
            }
        }

        function getApiStatusIcon(status) {
            switch (status) {
                case 'online': return 'âœ…';
                case 'timeout': return 'â±ï¸';
                case 'offline': return 'âŒ';
                case 'api_limit': return 'âš¡';
                case 'error': return 'ğŸ”´';
                default: return 'â“';
            }
        }

        function getApiStatusColor(status) {
            switch (status) {
                case 'online': return 'text-tv-green';
                case 'timeout': return 'text-yellow-500';
                case 'offline': return 'text-tv-red';
                case 'api_limit': return 'text-purple-500';
                case 'error': return 'text-tv-red';
                default: return 'text-tv-text-secondary';
            }
        }

        function getApiStatusText(status) {
            switch (status) {
                case 'online': return 'ì •ìƒ';
                case 'timeout': return 'ì‘ë‹µ ì§€ì—°';
                case 'offline': return 'ì˜¤í”„ë¼ì¸';
                case 'api_limit': return 'API ì œí•œ';
                case 'error': return 'ì˜¤ë¥˜';
                default: return 'ì•Œ ìˆ˜ ì—†ìŒ';
            }
        }

        // Initialize everything when page loads
        document.addEventListener('DOMContentLoaded', function() {
            console.log('ğŸ›ï¸ DOM Content Loaded - Initializing Korean Chart');
            
            // Hide loading states immediately
            const chartLoading = document.getElementById('chartLoading');
            const noStockSelected = document.getElementById('noStockSelected');
            if (chartLoading) chartLoading.style.display = 'none';
            if (noStockSelected) noStockSelected.style.display = 'none';
            
            // Initialize Korean candlestick chart
            initializeChart();
            
            // Add event listeners for time interval buttons
            document.querySelectorAll('.time-interval-btn').forEach(btn => {
                btn.addEventListener('click', function() {
                    // Remove active class from all buttons
                    document.querySelectorAll('.time-interval-btn').forEach(b => {
                        b.classList.remove('active', 'bg-blue-600');
                        b.classList.add('bg-gray-600');
                    });
                    
                    // Add active class to clicked button
                    this.classList.add('active', 'bg-blue-600');
                    this.classList.remove('bg-gray-600');
                    
                    // Update current interval
                    const interval = this.dataset.interval;
                    currentInterval = interval;
                    
                    // Update display
                    const currentIntervalEl = document.getElementById('currentInterval');
                    if (currentIntervalEl) {
                        const intervalMap = {
                            '1d': '1ì¼',
                            '1wk': '1ì£¼',
                            '1mo': '1ì›”',
                            '1y': '1ë…„'
                        };
                        currentIntervalEl.textContent = intervalMap[interval] || interval;
                    }
                    
                    // Reload data with new interval
                    if (currentStockSymbol) {
                        loadStockData(currentStockSymbol, 90, interval);
                    }
                });
            });
            
            // Auto-load a sample stock with real data after a brief delay
            setTimeout(() => {
                currentStockSymbol = 'AAPL'; // Use a US stock that's more likely to have data
                selectedStockName.textContent = 'Apple Inc.';
                selectedStockSymbol.textContent = 'AAPL';
                loadingPrice.style.display = 'block';
                
                // Load real stock data for the default stock
                loadStockData('AAPL', 90, '1d').then(() => {
                    console.log('Default stock data loaded successfully');
                    loadingPrice.style.display = 'none';
                }).catch(error => {
                    console.error('Failed to load default stock data:', error);
                    loadingPrice.style.display = 'none';
                    currentStockPrice.textContent = 'Data unavailable';
                });
            }, 500); // 500ms delay to ensure chart is properly initialized
            
            // Window resize handler for mobile orientation changes
            let resizeTimeout;
            window.addEventListener('resize', () => {
                clearTimeout(resizeTimeout);
                resizeTimeout = setTimeout(() => {
                    if (koreanChart && koreanChart.canvas) {
                        const container = koreanChart.canvas.parentElement;
                        const isMobile = window.innerWidth <= 640;
                        
                        // Update canvas size
                        koreanChart.canvas.width = container.clientWidth;
                        koreanChart.canvas.height = container.clientHeight;
                        koreanChart.width = koreanChart.canvas.width;
                        koreanChart.height = koreanChart.canvas.height;
                        
                        // Update padding for mobile
                        koreanChart.padding = isMobile 
                            ? { top: 15, right: 50, bottom: 30, left: 30 }
                            : { top: 20, right: 80, bottom: 40, left: 40 };
                        koreanChart.isMobile = isMobile;
                        
                        // Redraw chart
                        koreanChart.draw();
                    }
                }, 250);
            });
            
    console.log('Initialization complete');
    
    // BOSS FIX: Initialize all enhanced features
    setupChartClickHandler();
    setupAutoSave();
    addIconControlButtons();
    
    // BOSS FIX: Initialize TradingView-style mouse wheel functionality
    initializeTradingViewWheel();
    
    // BOSS FIX: Also initialize after a delay to ensure chart is ready
    setTimeout(() => {
        console.log('ğŸ”„ Delayed TradingView wheel initialization...');
        initializeTradingViewWheel();
    }, 2000);
    
    // Load saved configuration if available
    const savedConfig = loadChartConfiguration();
    if (savedConfig && savedConfig.stockSymbol) {
        console.log('ğŸ”„ BOSS FIX: Auto-loading saved configuration');
        loadStockData(savedConfig.stockSymbol);
    }
    
    console.log('âœ… BOSS FIX: All enhancements initialized successfully');
});        // TradingView-style Time Interval Button Handlers (EXACT LIKE REFERENCE)
        document.addEventListener('DOMContentLoaded', function() {
            // Initialize time interval buttons
            const timeIntervalButtons = document.querySelectorAll('.time-interval-btn');
            const chartTypeButtons = document.querySelectorAll('.chart-type-btn');
            
            // Time interval button click handlers
            timeIntervalButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    // Remove active class from all time interval buttons
                    timeIntervalButtons.forEach(b => b.classList.remove('active'));
                    
                    // Add active class to clicked button
                    this.classList.add('active');
                    
                    // Get interval value
                    const interval = this.dataset.interval;
                    console.log(`Selected time interval: ${interval}`);
                    
                    // Update chart with new interval (if chart exists)
                    if (koreanChart) {
                        // Map TradingView intervals to our internal format
                        let internalInterval = '1d';
                        switch(interval) {
                            case '1D': internalInterval = '1d'; break;
                            case '5D': internalInterval = '5d'; break;
                            case '1M': internalInterval = '1mo'; break;
                            case '3M': internalInterval = '3mo'; break;
                            case '6M': internalInterval = '6mo'; break;
                            case 'YTD': internalInterval = 'ytd'; break;
                            case '1Y': internalInterval = '1y'; break;
                            case '5Y': internalInterval = '5y'; break;
                            case 'ì „ì²´': internalInterval = 'max'; break;
                        }
                        
                        koreanChart.setTimeInterval(internalInterval);
                        
                        // Reload data with new interval if stock is selected
                        if (currentStockSymbol) {
                            loadStockData(currentStockSymbol, 90, internalInterval);
                        }
                    }
                });
            });
            
            // Chart type button click handlers
            chartTypeButtons.forEach(btn => {
                btn.addEventListener('click', function() {
                    // Remove active class from all chart type buttons
                    chartTypeButtons.forEach(b => b.classList.remove('active'));
                    
                    // Add active class to clicked button
                    this.classList.add('active');
                    
                    const chartType = this.dataset.type;
                    console.log(`Selected chart type: ${chartType}`);
                    
                    // Update chart type (currently only candlestick supported)
                    if (koreanChart) {
                        koreanChart.draw(); // Redraw with current type
                    }
                });
            });
            
            // Real-time clock update (EXACT LIKE REFERENCE: 22:55:33 UTC+9)
            function updateClock() {
                const now = new Date();
                const hours = String(now.getHours()).padStart(2, '0');
                const minutes = String(now.getMinutes()).padStart(2, '0');
                const seconds = String(now.getSeconds()).padStart(2, '0');
                const timeString = `${hours}:${minutes}:${seconds} UTC+9`;
                
                const clockElement = document.getElementById('currentTime');
                if (clockElement) {
                    clockElement.textContent = timeString;
                }
            }
            
            // Update clock every second
            updateClock(); // Initial update
            setInterval(updateClock, 1000);
            
            console.log('TradingView-style time controls initialized');
        });
    </script>

    <!-- Prediction Tooltip -->
    <div id="predictionTooltip" class="fixed bg-tv-card border border-tv-border rounded-lg p-3 text-sm z-50 hidden shadow-lg">
        <div class="text-tv-text-secondary text-xs mb-1">ì˜ˆì¸¡ ì •ë³´</div>
        <div class="text-tv-text">
            <div>ë‚ ì§œ: <span id="tooltipDate" class="text-tv-blue">-</span></div>
            <div>ê°€ê²©: <span id="tooltipPrice" class="text-tv-green">-</span></div>
        </div>
    </div>
</body>

</html>